<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroCMS Test - Google Sheet Data Entry</title>
</head>
<body>

    <h1>Google Sheet データ書き込み</h1>

    <form id="dataEntryForm" action="【以前のGASウェブアプリURL】" method="post" target="_blank">
        <label for="sceneName">シーン名:</label><br>
        <input type="text" id="sceneName" name="sceneName" required><br><br>

        <label for="episode">エピソード番号:</label><br>
        <input type="number" id="episode" name="episode" required><br><br>
        
        <input type="submit" value="データをシートに送信（旧方法）">
    </form>

    <div id="responseMessage"></div>

    <hr>
    
    <h1>既存のエピソードデータ表示 (プロキシ経由)</h1>
    <label for="episodeSelect">エピソードを選択:</label>
    <select id="episodeSelect">
        </select>
    <div id="contentDisplay">
        </div>

    <h2>新しいシーンを追加</h2>
    <form id="addSceneForm">
        <label for="newSceneName">シーン名:</label>
        <input type="text" id="newSceneName" required><br><br>
        <label for="newEpisode">エピソード番号:</label>
        <input type="number" id="newEpisode" required><br><br>
        <label for="newSpeaker">話者:</label>
        <input type="text" id="newSpeaker"><br><br>
        <label for="newDialogue">台詞:</label>
        <textarea id="newDialogue"></textarea><br><br>
        <button type="submit">シーンを追加</button>
    </form>
    <div id="addSceneMessage"></div>


    <script>
        // 【ここが重要！】GASのURLではなく、Vercelで作成したプロキシのパスを指定します。
        // Vercelにデプロイすると、`https://cat-seven-blond.vercel.app/api/gas-proxy`のようになります。
        const PROXY_BASE_URL = '/api/gas-proxy'; // 同じオリジン内のVercel Serverless Functionへのパス

        // 以前のfetchAllDataWithPagination関数（プロキシ経由に変更）
        async function fetchAllDataWithPagination(apiPath, params = {}, method = 'GET', body = null) {
            const queryParams = new URLSearchParams(params).toString();
            // プロキシ経由でアクセスするため、URLはVercelのパスに変わります
            const url = `${PROXY_BASE_URL}?api=${apiPath}&${queryParams}`;
            console.log("Fetching from URL (via Proxy):", url); // デバッグ用

            const options = {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                },
            };

            if (body && (method === 'POST' || method === 'PUT' || method === 'DELETE')) {
                options.body = JSON.stringify(body);
            }

            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                const data = await response.json();
                console.log("Fetched data (via Proxy):", data); // デバッグ用
                return data;
            } catch (error) {
                console.error("データ取得中にエラーが発生しました (プロキシ経由):", error);
                throw error; // エラーを再スローして呼び出し元で処理できるようにする
            }
        }

        // 以前のpopulateEpisodeSelect関数
        async function populateEpisodeSelect() {
            const episodeSelect = document.getElementById('episodeSelect');
            episodeSelect.innerHTML = '<option value="">エピソードを選択してください</option>'; // 初期オプション

            try {
                // プロキシ経由でGASのscenesデータを取得
                const scenes = await fetchAllDataWithPagination('scenes');
                if (!scenes || scenes.length === 0) {
                    console.warn('シーンデータが見つかりませんでした。');
                    return;
                }

                const episodes = [...new Set(scenes.map(scene => scene.episode))].sort((a, b) => a - b);
                episodes.forEach(episode => {
                    const option = document.createElement('option');
                    option.value = episode;
                    option.textContent = `エピソード ${episode}`;
                    episodeSelect.appendChild(option);
                });
            } catch (error) {
                console.error('エピソード番号の取得中にエラーが発生しました (プロキシ経由):', error);
                episodeSelect.innerHTML = '<option value="">エピソードのロードに失敗しました</option>';
            }
        }

        // 以前のdisplayContentForEpisode関数
        async function displayContentForEpisode(episode) {
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.innerHTML = '<h2>シーンデータ</h2>';

            if (!episode) {
                contentDisplay.innerHTML += '<p>エピソードを選択してください。</p>';
                return;
            }

            try {
                // プロキシ経由で特定のepisodeのscenesデータを取得
                const scenes = await fetchAllDataWithPagination('scenes', { episode: episode });
                if (scenes.length === 0) {
                    contentDisplay.innerHTML += `<p>エピソード ${episode} のシーンデータは見つかりませんでした。</p>`;
                    return;
                }

                const ul = document.createElement('ul');
                scenes.forEach(scene => {
                    const li = document.createElement('li');
                    li.innerHTML = `<strong>ID:</strong> ${scene.id}<br>
                                    <strong>シーン名:</strong> ${scene.sceneName}<br>
                                    <strong>エピソード:</strong> ${scene.episode}<br>
                                    <strong>話者:</strong> ${scene.speaker}<br>
                                    <strong>台詞:</strong> ${scene.dialogue}`;
                    // 編集・削除ボタンを追加
                    li.innerHTML += ` <button onclick="editScene('${scene.id}')">編集</button>
                                     <button onclick="deleteScene('${scene.id}')">削除</button>`;
                    ul.appendChild(li);
                });
                contentDisplay.appendChild(ul);
            } catch (error) {
                console.error(`エピソード ${episode} のシーンデータの表示中にエラーが発生しました (プロキシ経由):`, error);
                contentDisplay.innerHTML += `<p>エピソード ${episode} のデータ取得中にエラーが発生しました。</p>`;
            }
        }

        // シーン追加の処理 (POST)
        document.getElementById('addSceneForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            const messageDiv = document.getElementById('addSceneMessage');
            messageDiv.innerText = 'シーンを追加中...';

            const newScene = {
                sceneName: document.getElementById('newSceneName').value,
                episode: parseInt(document.getElementById('newEpisode').value, 10),
                speaker: document.getElementById('newSpeaker').value,
                dialogue: document.getElementById('newDialogue').value,
                // IDはGAS側で自動生成されることを期待
            };

            try {
                // プロキシ経由でPOSTリクエストを送信
                const result = await fetchAllDataWithPagination('scenes', {}, 'POST', newScene);
                messageDiv.innerText = `シーン追加成功: ${result.message} (ID: ${result.id})`;
                document.getElementById('addSceneForm').reset(); // フォームをリセット
                // データを更新して再表示
                populateEpisodeSelect();
                displayContentForEpisode(newScene.episode);
            } catch (error) {
                messageDiv.innerText = `シーン追加失敗: ${error.message}`;
                console.error('シーンの追加中にエラーが発生しました:', error);
            }
        });

        // シーン編集の処理 (PUT) - 簡易的なプロンプトでの例
        async function editScene(sceneId) {
            const newSceneName = prompt(`シーンID ${sceneId} の新しいシーン名を入力してください:`);
            if (newSceneName === null) return; // キャンセルされた場合

            const newEpisode = prompt(`シーンID ${sceneId} の新しいエピソード番号を入力してください:`);
            if (newEpisode === null) return;

            const updatedData = {
                sceneName: newSceneName,
                episode: parseInt(newEpisode, 10),
                // 他のフィールドも必要に応じて追加
            };

            try {
                // プロキシ経由でPUTリクエストを送信
                const result = await fetchAllDataWithPagination('scenes', { id: sceneId }, 'PUT', updatedData);
                alert(`シーンID ${sceneId} の更新成功: ${result.message}`);
                // データを更新して再表示
                populateEpisodeSelect();
                // 現在表示中のエピソードがあれば、それを更新
                const currentEpisode = document.getElementById('episodeSelect').value;
                if (currentEpisode) {
                    displayContentForEpisode(currentEpisode);
                }
            } catch (error) {
                alert(`シーンID ${sceneId} の更新失敗: ${error.message}`);
                console.error('シーンの更新中にエラーが発生しました:', error);
            }
        }

        // シーン削除の処理 (DELETE)
        async function deleteScene(sceneId) {
            if (!confirm(`シーンID ${sceneId} を本当に削除しますか？`)) {
                return;
            }

            try {
                // プロキシ経由でDELETEリクエストを送信
                const result = await fetchAllDataWithPagination('scenes', { id: sceneId }, 'DELETE');
                alert(`シーンID ${sceneId} の削除成功: ${result.message}`);
                // データを更新して再表示
                populateEpisodeSelect();
                // 現在表示中のエピソードがあれば、それを更新
                const currentEpisode = document.getElementById('episodeSelect').value;
                if (currentEpisode) {
                    displayContentForEpisode(currentEpisode);
                }
            } catch (error) {
                alert(`シーンID ${sceneId} の削除失敗: ${error.message}`);
                console.error('シーンの削除中にエラーが発生しました:', error);
            }
        }

        // 初期化関数
        async function initialize() {
            await populateEpisodeSelect();

            const episodeSelect = document.getElementById('episodeSelect');
            episodeSelect.addEventListener('change', (event) => {
                displayContentForEpisode(event.target.value);
            });

            // ページロード時に最初のエピソードを自動選択して表示 (オプション)
            if (episodeSelect.options.length > 1) {
                episodeSelect.value = episodeSelect.options[1].value;
                displayContentForEpisode(episodeSelect.value);
            }
        }

        // ページロード時に初期化関数を実行
        document.addEventListener('DOMContentLoaded', initialize);

    </script>
</body>
</html>