<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>勇者ハーレム - ノベルビューア（編集モード）</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        #header { height: 48px; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; }
        #novel-container { position: relative; height: calc(100% - 48px); }
        #background, #special-image { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 0; }
        #special-image { object-fit: contain; background: none; } /* 一枚絵の場合 */
        #character { position: absolute; bottom: -10%; left: 50%; transform: translateX(-50%); max-height: 70%; max-width: 100%; object-fit: contain; z-index: 1; transition: filter 0.3s ease; }
        #character.dimmed { filter: brightness(0.5); }
        #dialogue-box { position: absolute; bottom: 0; width: 100%; min-height: 120px; background: rgba(0,0,0,0.8); padding: 12px; box-sizing: border-box; z-index: 2; }
        #dialogue-text { font-size: 1.2em; line-height: 1.5; margin-bottom: 8px; }
        #speaker-name { font-weight: bold; color: #f80; margin-bottom: 4px; }
        #name-box { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 4px; font-weight: bold; color: #f80; z-index: 3; }
        #controls { position: absolute; top: 0; right: 0; padding: 8px; z-index: 10; display: flex; gap: 8px; }
        #controls button, .modal button { padding: 8px 12px; background: #333; color: #fff; border: none; border-radius: 4px; cursor: pointer; }
        #controls button:hover, .modal button:hover { background: #555; }
        #modal, #asset-upload-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: #222; padding: 20px; border-radius: 8px; text-align: center; max-width: 90%; max-height: 90%; overflow-y: auto; }
        .modal-content label, .modal-content input, .modal-content textarea, .modal-content select { display: block; margin-bottom: 10px; width: 100%; box-sizing: border-box; }
        .modal-content input[type="text"], .modal-content textarea, .modal-content select { padding: 8px; border: 1px solid #555; background: #333; color: #fff; border-radius: 4px; }
        .modal-content button { margin-top: 10px; }
        #edit-form-container { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); justify-content: center; align-items: center; z-index: 99; }
        #edit-form { background: #222; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%; overflow-y: auto; text-align: left; }
        #edit-form label { display: block; margin-bottom: 10px; color: #eee; }
        #edit-form input[type="text"], #edit-form textarea, #edit-form select { width: calc(100% - 16px); padding: 8px; border: 1px solid #555; background: #333; color: #fff; border-radius: 4px; }
        #edit-form button { padding: 8px 12px; background: #007bff; color: #fff; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; }
        #edit-form button:hover { background: #0056b3; }
        #scene-list-container { max-height: 300px; overflow-y: auto; border: 1px solid #555; margin-top: 10px; }
        .scene-item { padding: 8px; border-bottom: 1px solid #444; cursor: pointer; text-align: left; }
        .scene-item.current-scene { background-color: #007bff; }
        #log-area {
            position: absolute;
            top: 48px;
            left: 0;
            width: 100%;
            height: calc(100% - 48px);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            transform: translateY(100%); /* Initially hidden below */
            transition: transform 0.3s ease-in-out;
            z-index: 50;
        }
        #log-area.expanded {
            transform: translateY(0); /* Expanded to show */
        }
        .log-entry { margin-bottom: 10px; }
        .log-entry strong { color: #f80; } /* Speaker name in log */
    </style>
</head>
<body>
    <div id="header">
        <span id="episode-info">エピソード 1 - シーン 1</span>
        <div>
            <button onclick="toggleEditForm()">編集</button>
            <button onclick="showAssetUploadModal()">アセットアップロード</button>
            <button onclick="toggleLog()">ログ</button>
        </div>
    </div>
    <div id="novel-container">
        <div id="background"></div>
        <img id="special-image" src="" alt="" style="display: none;" />
        <img id="character" src="" alt="" style="display: none;" />

        <div id="dialogue-box">
            <div id="speaker-name"></div>
            <div id="dialogue-text"></div>
        </div>
        <div id="name-box" style="display: none;"></div>
    </div>

    <div id="edit-form-container">
        <div id="edit-form">
            <label>シーンID：<input type="text" id="edit-scene-id" readonly /></label>
            <label>チャプター：<input type="number" id="edit-chapter" min="1" /></label>
            <label>エピソード：<input type="number" id="edit-episode" min="1" /></label>
            <label>シーン番号：<input type="number" id="edit-scene" min="1" /></label>
            <label>話者：<select id="edit-speaker"></select></label>
            <label>セリフ：<textarea id="edit-text" rows="3"></textarea></label>
            <label>表情：<select id="edit-face"></select></label>
            <label>背景：<select id="edit-bg"></select></label>
            <label>特殊：<input type="text" id="edit-special" placeholder="特殊効果やアセットタグ" /></label>
            <button onclick="applyEdits()">✅ 適用</button>
            <button onclick="deleteScene()" style="background: #a00; margin-left: 8px;">🗑️ このシーンを削除</button>
            <button onclick="addScene()" style="background: #0a0; margin-left: 8px;">➕ シーンを追加</button>
            <button onclick="cancelEdit()" style="background: #555; margin-left: 8px;">キャンセル</button>
            <hr style="margin-top: 20px; border-color: #555;" />
            <h3>シーンリスト</h3>
            <div id="scene-list-container">
                </div>
        </div>
    </div>

    <div id="asset-upload-modal">
        <div class="modal-content">
            <h2>アセットアップロード</h2>
            <label>アセットファイル：<input type="file" id="asset-file" accept="image/*" /></label>
            <label>アセットタイプ：
                <select id="asset-type-select">
                    <option value="character">キャラクター</option>
                    <option value="background">背景</option>
                    <option value="special_image">一枚絵</option>
                    <option value="character_face">キャラクター表情アセット</option>
                    </select>
            </label>
            <label>タグ（必須）：<input type="text" id="asset-tag" placeholder="例: チハル, 森" /></label>
            <label id="character-face-tag-label" style="display: none;">表情タグ（任意）：<input type="text" id="character-face-tag" placeholder="例: 笑顔, 冷笑" /></label>
            <label id="character-special-label" style="display: none;">特殊（任意）：<input type="text" id="character-special" placeholder="例: winter, ver2" /></label>
            <button onclick="handleAssetUpload()">アップロード</button>
            <button onclick="hideAssetUploadModal()">キャンセル</button>
        </div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <p id="modal-message"></p>
            <button id="modal-confirm-btn">はい</button>
            <button id="modal-cancel-btn">いいえ</button>
        </div>
    </div>

    <div id="log-area">
        <h3 style="text-align: center;">ログ</h3>
        <div id="log-content"></div>
    </div>

    <script>
        // 環境変数とパス定義
        const ASSETS_PROXY_PATH = '/api/assets'; // assets.mjs を叩くパス
        const SCENES_PROXY_PATH = '/api/scenes'; // scenes.mjs を叩くパス
        const SPECIFIC_SCENE_PROXY_PATH = '/api/scenes/'; // api/scenes/[id].mjs を叩くパス

        // グローバル変数
        let currentEpisode = 1;
        let currentSceneIndex = 0;
        let episodeData = [];
        let currentEditingScene = null; // 現在編集中のシーンオブジェクト
        let touchStartTime = 0; // スワイプ検出用

        // キャッシュ用の変数
        let speakersDataCache = [];
        let facesDataCache = [];
        let backgroundsDataCache = [];

        // --- API呼び出しヘルパー関数 ---

        // MicroCMSからデータをページネーションで全て取得する汎用関数
        // フロントエンドから直接 MicroCMS API を叩くわけではなく、Vercel の /api エンドポイントを叩く想定
        async function fetchAllDataWithPagination(apiEndpoint, filters = [], limit = 100, offset = 0, specificMicroCMSEndpoint = null) {
            let allData = [];
            let currentOffset = offset;
            let hasMore = true;

            const url = new URL(window.location.origin + apiEndpoint); // VercelのAPIルートのURLを構築
            if (specificMicroCMSEndpoint) {
                // MicroCMS側の特定のエンドポイントを指定する場合 (例: /api/scenes?endpoint=speakers)
                // バックエンドでこの 'endpoint' パラメータを解釈してMicroCMSにリクエストを転送する必要があります
                url.searchParams.append('microcms_endpoint', specificMicroCMSEndpoint);
            }
            url.searchParams.append('limit', limit);
            url.searchParams.append('offset', currentOffset);
            
            // filtersを配列として扱い、各フィルターを個別の'filters'パラメータとして追加
            filters.forEach(filter => {
                if (filter) { // nullや空文字列のフィルターを除外
                    url.searchParams.append('filters', filter);
                }
            });

            console.log(`[FE] Fetching data from: ${url.toString()}`);

            try {
                const response = await fetch(url.toString());
                const data = await response.json();

                if (!response.ok) {
                    const errorMessage = data.error || response.statusText;
                    const details = data.details ? `Details: ${JSON.stringify(data.details)}` : '';
                    throw new Error(`API Error (${apiEndpoint}): ${response.status} - ${errorMessage} ${details}`);
                }

                allData = allData.concat(data.contents || data); // data.contentsがある場合はそれを使用、ない場合はdata自体を使用

                // totalCount が存在する場合、それを使ってhasMoreを判定
                if (data.totalCount !== undefined) {
                    hasMore = (currentOffset + limit) < data.totalCount;
                } else {
                    // totalCount がない場合、取得したデータの量で判定
                    hasMore = data.contents && data.contents.length === limit;
                }
                
                currentOffset += limit;
            } catch (error) {
                console.error(`[FE] Error fetching data from API route ${apiEndpoint}:`, error);
                throw error;
            }
            
            return allData;
        }

        // --- ドロップダウンオプションのロード ---
        async function loadDropdownOptions() {
            try {
                // MicroCMSのセレクトフィールドの選択肢は、通常API経由では直接取得できません。
                // そのため、ここでは MicroCMSのassetsから、対応するタグを持つアセットをリストアップすることで、
                // 話者、表情、背景の選択肢を擬似的に取得します。

                // 話者リストの取得: asset_type=characterのアセットのtagを集める
                const characterAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, ['asset_type[equals]character']);
                speakersDataCache = Array.from(new Set(characterAssets.map(a => a.tag).filter(Boolean)));
                
                // 表情リストの取得: character_face_tagを持つアセットのcharacter_face_tagを集める
                // （character_face_tagはテキストフィールドなので、ユニークな値を収集）
                const faceAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, ['character_face_tag[exists]']);
                facesDataCache = Array.from(new Set(faceAssets.map(a => a.character_face_tag).filter(Boolean)));

                // 背景リストの取得: asset_type=backgroundのアセットのtagを集める
                const backgroundAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, ['asset_type[equals]background']);
                backgroundsDataCache = Array.from(new Set(backgroundAssets.map(a => a.tag).filter(Boolean)));
                
                console.log('Dropdown options loaded:', { speakers: speakersDataCache, faces: facesDataCache, backgrounds: backgroundsDataCache });

            } catch (error) {
                console.error('Failed to load dropdown options:', error);
                alert('選択肢の読み込み中にエラーが発生しました。コンソールを確認してください。');
            }
        }


        // --- シーンデータ関連関数 ---

        async function loadEpisodeData() {
            try {
                // エピソードデータをロード
                const filters = [`episode[equals]${currentEpisode}`];
                console.log(`[FE] Loading scenes data for episode: ${currentEpisode}`);
                const data = await fetchAllDataWithPagination(SCENES_PROXY_PATH + `?episode=${currentEpisode}`);
                
                episodeData = data.sort((a, b) => a.sceneNumber - b.sceneNumber);
                if (episodeData.length === 0) {
                    // エピソードデータがない場合、デフォルトシーンを作成
                    episodeData = [{
                        id: 'new-scene-001', // 仮のID
                        chapterNumber: currentEpisode,
                        episode: currentEpisode,
                        sceneNumber: 1,
                        speaker: '',
                        text: '新しい物語が始まります。',
                        face: '',
                        background: '',
                        special: ''
                    }];
                    console.warn(`[FE] No data found for episode ${currentEpisode}. Created a default scene.`);
                }
                
                displayScene(currentSceneIndex);
                updateSceneList(); // シーンリストも更新

            } catch (error) {
                console.error(`[FE] エピソード ${currentEpisode} のデータ読み込み中にエラーが発生しました:`, error);
                alert(`エピソード ${currentEpisode} のデータ読み込み中にエラーが発生しました。コンソールを確認してください。`);
            }
        }

        function displayScene(index) {
            if (index < 0 || index >= episodeData.length) {
                console.warn(`[FE] Scene index ${index} out of bounds.`);
                return;
            }

            currentSceneIndex = index;
            const scene = episodeData[currentSceneIndex];

            document.getElementById('episode-info').textContent = `エピソード ${scene.episode} - シーン ${scene.sceneNumber}`;
            document.getElementById('speaker-name').textContent = scene.speaker || '';
            document.getElementById('dialogue-text').textContent = scene.text || '';
            
            // 名前の表示制御
            const nameBox = document.getElementById('name-box');
            if (scene.speaker && scene.speaker !== 'モノローグ') { // モノローグでない場合のみ表示
                nameBox.textContent = scene.speaker;
                nameBox.style.display = 'block';
            } else {
                nameBox.style.display = 'none';
            }

            // 背景画像の表示
            const backgroundElement = document.getElementById('background');
            if (scene.background) {
                // scene.background が既にURLの場合と、タグ名の場合に対応
                backgroundElement.style.backgroundImage = `url('${scene.background}')`;
            } else {
                backgroundElement.style.backgroundImage = 'none';
            }

            // キャラクター画像の表示
            const characterElement = document.getElementById('character');
            if (scene.speaker && scene.speaker !== 'モノローグ') {
                // `asset_type`がセレクトフィールドなので`equals`を使用
                let charFilter = `asset_type[equals]character[and]tag[equals]${scene.speaker}`;
                if (scene.face) { // 表情が指定されている場合
                    charFilter += `[and]character_face_tag[equals]${scene.face}`;
                }
                if (scene.special) { // 特殊タグが指定されている場合
                    charFilter += `[and]character_special[equals]${scene.special}`;
                }

                // assetsエンドポイントからキャラクターアセットを検索
                fetchAllDataWithPagination(ASSETS_PROXY_PATH, [charFilter])
                    .then(charAssets => {
                        if (charAssets && charAssets.length > 0) {
                            characterElement.src = charAssets[0].image.url;
                            characterElement.style.display = 'block';
                            // 関連するログアイテムの背景色を更新
                            updateLogEntryHighlight(scene.sceneNumber, true);
                        } else {
                            console.warn(`[FE] Character asset not found for speaker: ${scene.speaker}, face: ${scene.face}, special: ${scene.special}`);
                            characterElement.style.display = 'none';
                            updateLogEntryHighlight(scene.sceneNumber, false);
                        }
                    })
                    .catch(error => {
                        console.error(`[FE] Error fetching character asset for ${scene.speaker}:`, error);
                        characterElement.style.display = 'none';
                        updateLogEntryHighlight(scene.sceneNumber, false);
                    });
            } else {
                characterElement.style.display = 'none';
                updateLogEntryHighlight(scene.sceneNumber, true); // セリフのみのシーンもハイライト
            }

            // 特殊画像（一枚絵など）の表示
            const specialImageElement = document.getElementById('special-image');
            if (scene.special && scene.speaker === 'モノローグ') { // モノローグで特殊が指定されている場合を一枚絵と仮定
                 // `asset_type`がセレクトフィールドなので`equals`を使用
                fetchAllDataWithPagination(ASSETS_PROXY_PATH, [`asset_type[equals]special_image[and]tag[equals]${scene.special}`])
                    .then(specialAssets => {
                        if (specialAssets && specialAssets.length > 0) {
                            specialImageElement.src = specialAssets[0].image.url;
                            specialImageElement.style.display = 'block';
                        } else {
                            console.warn(`[FE] Special image asset not found for tag: ${scene.special}`);
                            specialImageElement.style.display = 'none';
                        }
                    })
                    .catch(error => {
                        console.error(`[FE] Error fetching special image asset for ${scene.special}:`, error);
                        specialImageElement.style.display = 'none';
                    });
            } else {
                specialImageElement.style.display = 'none';
            }
            updateLog(); // ログを更新
            updateSceneListHighlight(); // シーンリストのハイライトを更新
        }

        function goToNextScene() {
            if (currentSceneIndex < episodeData.length - 1) {
                displayScene(currentSceneIndex + 1);
            } else {
                alert('このエピソードは終わりです！');
            }
        }

        function goToPreviousScene() {
            if (currentSceneIndex > 0) {
                displayScene(currentSceneIndex - 1);
            } else {
                alert('このエピソードの最初のシーンです。');
            }
        }

        // --- 編集フォーム関連関数 ---

        function toggleEditForm() {
            const formContainer = document.getElementById('edit-form-container');
            if (formContainer.style.display === 'flex') {
                formContainer.style.display = 'none';
            } else {
                updateEditForm(episodeData[currentSceneIndex]);
                formContainer.style.display = 'flex';
            }
        }

        function cancelEdit() {
            document.getElementById('edit-form-container').style.display = 'none';
        }


        // --- 修正箇所 ---
        function updateEditForm(scene) {
            currentEditingScene = scene; // 現在編集中のシーンを設定

            // プルダウン要素の取得
            const speakerSelect = document.getElementById('edit-speaker');
            const faceSelect = document.getElementById('edit-face');
            const bgSelect = document.getElementById('edit-bg');

            // 既存のオプションをクリア
            speakerSelect.innerHTML = '';
            faceSelect.innerHTML = '';
            bgSelect.innerHTML = '';

            // 各プルダウンにオプションを追加
            // 話者
            speakersDataCache.forEach(speaker => {
                const option = document.createElement('option');
                option.value = speaker;
                option.textContent = speaker;
                speakerSelect.appendChild(option);
            });
            // 空のオプションを追加（未選択状態を許容する場合）
            const speakerDefaultOption = document.createElement('option');
            speakerDefaultOption.value = '';
            speakerDefaultOption.textContent = '選択してください';
            speakerSelect.prepend(speakerDefaultOption);


            // 表情
            facesDataCache.forEach(face => {
                const option = document.createElement('option');
                option.value = face;
                option.textContent = face;
                faceSelect.appendChild(option);
            });
            // 空のオプションを追加
            const faceDefaultOption = document.createElement('option');
            faceDefaultOption.value = '';
            faceDefaultOption.textContent = '選択してください';
            faceSelect.prepend(faceDefaultOption);

            // 背景
            backgroundsDataCache.forEach(bg => {
                const option = document.createElement('option');
                option.value = bg;
                option.textContent = bg;
                bgSelect.appendChild(option);
            });
            // 空のオプションを追加
            const bgDefaultOption = document.createElement('option');
            bgDefaultOption.value = '';
            bgDefaultOption.textContent = '選択してください';
            bgSelect.prepend(bgDefaultOption);


            // シーンのデータをフォームに反映
            document.getElementById('edit-scene-id').value = scene.id || '';
            document.getElementById('edit-chapter').value = scene.chapterNumber || '';
            document.getElementById('edit-episode').value = scene.episode || '';
            document.getElementById('edit-scene').value = scene.sceneNumber || '';
            document.getElementById('edit-speaker').value = scene.speaker || ''; // scene.speakerがnull/undefinedの場合に空文字列
            document.getElementById('edit-text').value = scene.text || '';
            document.getElementById('edit-face').value = scene.face || '';
            document.getElementById('edit-bg').value = scene.background || '';
            document.getElementById('edit-special').value = scene.special || '';

            // フォームを表示
            document.getElementById('edit-form-container').style.display = 'flex';
        }
        // --- 修正箇所ここまで ---


        async function applyEdits() {
            const sceneId = document.getElementById('edit-scene-id').value;
            const updatedData = {
                chapterNumber: parseInt(document.getElementById('edit-chapter').value),
                episode: parseInt(document.getElementById('edit-episode').value),
                sceneNumber: parseInt(document.getElementById('edit-scene').value),
                speaker: document.getElementById('edit-speaker').value,
                text: document.getElementById('edit-text').value,
                face: document.getElementById('edit-face').value,
                background: document.getElementById('edit-bg').value,
                special: document.getElementById('edit-special').value,
            };

            try {
                const response = await fetch(SPECIFIC_SCENE_PROXY_PATH + sceneId, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(updatedData),
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to update scene.');
                }

                console.log('[FE] Scene updated successfully:', data);
                alert('シーンが更新されました！');
                document.getElementById('edit-form-container').style.display = 'none';
                await loadEpisodeData(); // 更新後、データを再ロードしてUIを最新にする

            } catch (error) {
                console.error('[FE] Error applying edits:', error);
                alert('シーンの更新に失敗しました: ' + error.message);
            }
        }

        async function deleteScene() {
            const sceneId = document.getElementById('edit-scene-id').value;
            if (!sceneId || sceneId.startsWith('new-scene-')) {
                alert('新規作成された未保存のシーンは削除できません。');
                return;
            }

            const confirmDelete = await showConfirmModal('このシーンを本当に削除しますか？');
            if (!confirmDelete) return;

            try {
                const response = await fetch(SPECIFIC_SCENE_PROXY_PATH + sceneId, {
                    method: 'DELETE',
                });

                if (!response.ok) {
                    const data = await response.json();
                    throw new Error(data.error || 'Failed to delete scene.');
                }

                console.log('[FE] Scene deleted successfully.');
                alert('シーンが削除されました！');
                document.getElementById('edit-form-container').style.display = 'none';
                await loadEpisodeData(); // 削除後、データを再ロードしてUIを最新にする

            } catch (error) {
                console.error('[FE] Error deleting scene:', error);
                alert('シーンの削除に失敗しました: ' + error.message);
            }
        }

        async function addScene() {
            const newSceneNumber = episodeData.length > 0 ? Math.max(...episodeData.map(s => s.sceneNumber)) + 1 : 1;
            const newScene = {
                id: `new-scene-${Date.now()}`, // 一時的なクライアントサイドID
                chapterNumber: currentEpisode,
                episode: currentEpisode,
                sceneNumber: newSceneNumber,
                speaker: '',
                text: '新しいシーンのセリフ',
                face: '',
                background: '',
                special: ''
            };

            // 新しいシーンを既存のデータに追加
            episodeData.push(newScene);
            // シーン番号でソート
            episodeData.sort((a, b) => a.sceneNumber - b.sceneNumber);

            // 編集フォームを新しいシーンで開く
            updateEditForm(newScene);
            updateSceneList(); // シーンリストを更新
            alert('新しいシーンが追加されました。編集後「適用」で保存してください。');
        }

        function updateSceneList() {
            const sceneListContainer = document.getElementById('scene-list-container');
            sceneListContainer.innerHTML = ''; // クリア

            episodeData.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = 'scene-item';
                sceneItem.textContent = `シーン ${scene.sceneNumber}: ${scene.speaker || ''}「${scene.text.substring(0, 20)}...」`;
                sceneItem.dataset.index = index;
                sceneItem.onclick = () => {
                    displayScene(index); // シーン表示
                    updateEditForm(scene); // 編集フォームもそのシーンで開く
                };
                sceneListContainer.appendChild(sceneItem);
            });
            updateSceneListHighlight(); // ハイライトも更新
        }

        function updateSceneListHighlight() {
            const sceneItems = document.querySelectorAll('.scene-item');
            sceneItems.forEach(item => {
                if (parseInt(item.dataset.index) === currentSceneIndex) {
                    item.classList.add('current-scene');
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    item.classList.remove('current-scene');
                }
            });
        }


        // --- アセットアップロード関連関数 ---

        function showAssetUploadModal() {
            document.getElementById('asset-upload-modal').style.display = 'flex';
            // asset_typeがcharacter_faceの場合に表情タグと特殊フィールドを表示
            document.getElementById('asset-type-select').addEventListener('change', function() {
                const isCharacterFace = this.value === 'character_face';
                document.getElementById('character-face-tag-label').style.display = isCharacterFace ? 'block' : 'none';
                document.getElementById('character-special-label').style.display = isCharacterFace ? 'block' : 'none';
            });
        }

        function hideAssetUploadModal() {
            document.getElementById('asset-upload-modal').style.display = 'none';
        }

        async function handleAssetUpload() {
            const fileInput = document.getElementById('asset-file');
            const assetType = document.getElementById('asset-type-select').value;
            const assetTag = document.getElementById('asset-tag').value;
            const characterFaceTag = document.getElementById('character-face-tag').value;
            const characterSpecial = document.getElementById('character-special').value;

            if (!fileInput.files.length || !assetTag) {
                alert('ファイルとタグは必須です！');
                return;
            }

            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            // asset_type はセレクトフィールド（MicroCMSで複数選択ではない場合）のため、単一の値として送る。
            // もし MicroCMS で複数選択を許可するチェックボックスフィールドなどであれば、配列として送信する必要がある
            formData.append('asset_type', assetType); // セレクトフィールドなので配列ではなく単一の値

            formData.append('tag', assetTag);
            
            // character_face_tag と character_special は、値があれば追加
            if (characterFaceTag) {
                formData.append('character_face_tag', characterFaceTag);
            }
            if (characterSpecial) {
                formData.append('character_special', characterSpecial);
            }
            
            try {
                const response = await fetch(ASSETS_PROXY_PATH, {
                    method: 'POST',
                    body: formData,
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to upload asset.');
                }

                alert('アセットが正常にアップロードされました！');
                hideAssetUploadModal();
                // アップロード成功後、ドロップダウンリストを再ロードして最新の状態を反映
                await loadDropdownOptions();

            } catch (error) {
                console.error('[FE] Error uploading asset:', error);
                alert('アセットのアップロードに失敗しました: ' + error.message);
            }
        }


        // --- モーダル関数 ---

        function showConfirmModal(message) {
            return new Promise((resolve) => {
                document.getElementById('modal-message').textContent = message;
                document.getElementById('modal-confirm-btn').onclick = () => {
                    document.getElementById('modal').style.display = 'none';
                    resolve(true);
                };
                document.getElementById('modal-cancel-btn').onclick = () => {
                    document.getElementById('modal').style.display = 'none';
                    resolve(false);
                };
                document.getElementById('modal').style.display = 'flex';
            });
        }

        // --- ログ機能 ---
        const dialogueBox = document.getElementById('dialogue-box');
        const logArea = document.getElementById('log-area');
        const logContent = document.getElementById('log-content');

        function toggleLog() {
            if (logArea.classList.contains('expanded')) {
                collapseLog();
            } else {
                expandLog();
            }
        }

        function expandLog() {
            logArea.classList.add('expanded');
            document.body.style.overflow = 'hidden'; // 背景のスクロールを禁止
        }

        function collapseLog() {
            logArea.classList.remove('expanded');
            document.body.style.overflow = ''; // 背景のスクロールを許可
        }

        function updateLog() {
            logContent.innerHTML = '';
            episodeData.forEach((scene, index) => {
                const logEntry = document.createElement('p');
                logEntry.className = 'log-entry';
                let speakerHtml = scene.speaker ? `<strong>${scene.speaker}</strong>: ` : '';
                logEntry.innerHTML = `${speakerHtml}${scene.text}`;
                logEntry.dataset.sceneNumber = scene.sceneNumber; // シーン番号をデータ属性として追加
                logEntry.onclick = () => {
                    displayScene(index);
                    collapseLog(); // ログを閉じる
                };
                logContent.appendChild(logEntry);
            });
            // 現在のシーンをログ内でハイライト
            updateLogEntryHighlight(episodeData[currentSceneIndex].sceneNumber, true);
        }

        function updateLogEntryHighlight(sceneNumber, highlight) {
            const logEntries = document.querySelectorAll('.log-entry');
            logEntries.forEach(entry => {
                if (parseInt(entry.dataset.sceneNumber) === sceneNumber) {
                    entry.style.backgroundColor = highlight ? 'rgba(0, 123, 255, 0.5)' : 'transparent';
                } else {
                    entry.style.backgroundColor = 'transparent';
                }
            });
        }


        // --- スワイプ/タップ検出 ---
        let startY = 0;
        let startX = 0;

        document.body.addEventListener('touchstart', e => {
            if (document.getElementById("modal").style.display === "flex" ||
                document.getElementById("asset-upload-modal").style.display === "flex" ||
                document.getElementById("edit-form-container").style.display === "flex") {
                return;
            }
            startY = e.changedTouches[0].clientY;
            startX = e.changedTouches[0].clientX;
            touchStartTime = Date.now();
        });

        document.body.addEventListener('touchend', e => {
            if (document.getElementById("modal").style.display === "flex" ||
                document.getElementById("asset-upload-modal").style.display === "flex" ||
                document.getElementById("edit-form-container").style.display === "flex") {
                return;
            }
            const endY = e.changedTouches[0].clientY;
            const endX = e.changedTouches[0].clientX;
            const dy = startY - endY;
            const dx = startX - endX;
            const dt = Date.now() - touchStartTime;

            const isExpanded = dialogueBox.classList.contains('expanded');

            // 上スワイプでログ展開 (50px以上上、横移動は50px以内、300ms以内)
            if (dy > 50 && Math.abs(dx) < 50 && dt < 300 && !isExpanded) {
                expandLog();
                return;
            }
            // 下スワイプでログ折りたたみ (50px以上下、横移動は50px以内、300ms以内)
            if (endY - startY > 50 && Math.abs(dx) < 50 && dt < 300 && isExpanded) {
                collapseLog();
                return;
            }
            // 長押しでログトグル (移動量が少なく、500ms以上)
            if (Math.abs(dy) < 10 && Math.abs(dx) < 10 && dt >= 500) {
                if (isExpanded) {
                    collapseLog();
                } else {
                    expandLog();
                }
                return;
            }
        });

        document.body.addEventListener('click', e => {
            // モーダルや編集フォーム、ログがアクティブな場合はクリックを処理しない
            if (document.getElementById("modal").style.display === "flex" ||
                document.getElementById("asset-upload-modal").style.display === "flex" ||
                document.getElementById("edit-form-container").style.display === "flex" ||
                logArea.classList.contains('expanded')) { // ログ展開時もクリックを処理しない
                return;
            }

            // コントロールやヘッダー内のクリックは無視
            if (e.target.closest('#edit-form') || e.target.closest('#controls') || e.target.closest('#header')) {
                return;
            }
            
            // それ以外は次のシーンへ
            goToNextScene();
        });


        // --- 初期ロード ---
        document.addEventListener('DOMContentLoaded', async () => {
            // ドロップダウンオプションを先にロード
            await loadDropdownOptions(); 
            // その後エピソードデータをロードし、最初のシーンを表示
            await loadEpisodeData();
        });
    </script>
</body>
</html>