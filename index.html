<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>勇者ハーレム - ノベルビューア（編集モード）</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        #header { height: 48px; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; }
        #novel-container { position: relative; height: calc(100% - 48px); }
        #background, #special-image { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 0; }
        #special-image { object-fit: contain; background: none; } /* 一枚絵の場合 */
        #character { position: absolute; bottom: -10%; left: 50%; transform: translateX(-50%); max-height: 70%; max-width: 100%; object-fit: contain; z-index: 1; transition: filter 0.3s ease; }
        #character.dimmed { filter: brightness(40%) saturate(50%); }
        #dialogue-box { position: absolute; bottom: 0; width: 100%; height: 25%; background: rgba(0, 0, 0, 0.6); padding: 16px; z-index: 2; transition: height 0.3s ease; overflow: hidden; box-sizing: border-box; }
        #dialogue-box.expanded { height: 80%; overflow-y: auto; }
        #speaker { font-weight: bold; }
        #text { margin-top: 8px; line-height: 1.6; }
        #edit-form { display: none; }
        #dialogue-box.expanded #edit-form { display: block; margin-top: 12px; }
        label { display: block; margin-top: 8px; }
        select, textarea, input { width: 100%; margin-top: 4px; font-size: 14px; padding: 4px; box-sizing: border-box; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #555; border-radius: 4px;}
        button { margin-top: 12px; padding: 6px 12px; background: #333; color: #fff; border: none; cursor: pointer; border-radius: 4px; }
        .episode-nav-btn { background: #555; margin: 0 5px; }
        #close-log { display: none; position: absolute; top: 8px; right: 12px; font-size: 20px; cursor: pointer; z-index: 3; }
        #dialogue-box.expanded #close-log { display: block; }
        #modal {
            display: none; position: fixed; z-index: 10;
            left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); justify-content: center; align-items: center;
        }
        #modal-content {
            background: #222; padding: 20px; border-radius: 8px; width: 90%; max-width: 400px;
            position: relative; /* Closeボタンの位置決めのため */
        }
        #modal-close {
            position: absolute; top: 10px; right: 20px; font-size: 24px; cursor: pointer;
        }
        #loading-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); color: white;
            justify-content: center; align-items: center; font-size: 24px; z-index: 100;
        }
    </style>
</head>
<body>
<div id="header">
    <div id="episode-navigation">
        <button class="episode-nav-btn" onclick="changeEpisode(-1)">◀ </button>
        <span id="current-episode-display">第1話</span>
        <button class="episode-nav-btn" onclick="changeEpisode(1)"> ▶</button>
    </div>
    <div id="scene-title">#1</div>
    <div id="controls">
        <button onclick="openModal()">⚙️ 設定</button>
    </div>
</div>
<div id="novel-container">
    <div id="background"></div>
    <img id="special-image" src="" alt="" style="display:none;" /> <img id="character" src="" alt="" />
    <div id="dialogue-box">
        <div id="speaker"></div>
        <div id="text"></div>
        <div id="edit-form">
            <label>話者：<select id="edit-speaker"></select></label>
            <label>セリフ：<textarea id="edit-text" rows="3"></textarea></label>
            <label>表情：<select id="edit-face"></select></label>
            <label>背景：<select id="edit-bg"></select></label>
            <label>特殊：<input type="text" id="edit-special" placeholder="特殊効果やアセットタグ" /></label>
            <label>エピソード：<input type="number" id="edit-episode" min="1" value="1" /></label>
            <label>シーン番号：<input type="number" id="edit-scene-number" min="1" value="1" /></label>
            <button onclick="applyEdits()">✅ 適用</button>
            <button onclick="deleteScene()" style="background: #a00; margin-left: 8px;">🗑️ このシーンを削除</button>
            <button onclick="addScene()" style="background: #0a0; margin-left: 8px;">➕ シーンを追加</button>
        </div>
        <div id="close-log" onclick="collapseLog()">✕</div>
    </div>
</div>
<div id="modal">
    <div id="modal-content">
        <div id="modal-close" onclick="closeModal()">✕</div>
        <h2>設定メニュー</h2>
        <button onclick="saveProgress()">💾 進行状況を保存</button><br><br>
        <button onclick="loadProgress()">📂 続きから再開</button><br><br>
        <button onclick="toggleVoice()">🔊 読み上げ: <span id="voice-status">オフ</span></button><br><br>
        <button onclick="downloadAllScenes()">⬇️ 全シーンをJSONで保存</button><br><br>
        <button onclick="uploadScenes()">⬆️ 全シーンをJSONでアップロード</button><br><br>
        <a href="assets_editor.html" target="_blank" style="display: block; margin-top: 15px; color: #87CEEB; text-decoration: none;">🖼️ アセット管理ページを開く</a>
    </div>
</div>

<input type="file" id="file-input" style="display: none;" accept=".json" onchange="handleFileUpload(event)">
<div id="loading-overlay">データを読み込み中...</div>

<script>
// microCMS API情報 - あなたの情報に置き換えてください！
const MICROCMS_SERVICE_ID = "nvw9sy9y9b";
const SCENES_API_ENDPOINT = "scenes";
const ASSETS_API_ENDPOINT = "assets"; // 統合されたアセットAPIエンドポイント

const SCENES_API_KEY = "fA7lEFFe3cPFr0zfmbnhckYWS79QT2QKdFiy"; // あなたのAPIキー
const ASSETS_API_KEY = "fA7lEFFe3cPFr0zfmbnhckYWS79QT2QKdFiy"; // あなたのAPIキー

const scenesApiBase = `https://${MICROCMS_SERVICE_ID}.microcms.io/api/v1/${SCENES_API_ENDPOINT}`;
const assetsApiBase = `https://${MICROCMS_SERVICE_ID}.microcms.io/api/v1/${ASSETS_API_ENDPOINT}`;

let currentEpisodeScenes = []; // 現在のエピソードのシーンデータ
let loadedAssets = { backgrounds: {}, characters: {}, effects: {}, specialImages: {} }; // 読み込んだアセットをキャッシュ
let currentSceneIndex = 0; // 現在表示中のシーンの配列インデックス
let useVoice = false;
let currentEpisodeNumber = 1; // 現在表示中のエピソード番号

// UI要素の取得
const speakerSelect = document.getElementById("edit-speaker");
const faceSelect = document.getElementById("edit-face");
const bgSelect = document.getElementById("edit-bg");
const characterElement = document.getElementById("character");
const specialImageElement = document.getElementById("special-image"); // 新しい要素
const backgroundElement = document.getElementById("background"); // 背景要素
const loadingOverlay = document.getElementById('loading-overlay');


// --- 初期化とデータ読み込み ---
document.addEventListener('DOMContentLoaded', async () => {
    // ローカルストレージから保存されたエピソード番号をロード
    const savedEpisode = localStorage.getItem('yh_current_episode');
    if (savedEpisode && !isNaN(parseInt(savedEpisode))) {
        currentEpisodeNumber = parseInt(savedEpisode);
    }
    document.getElementById('current-episode-display').textContent = `第${currentEpisodeNumber}話`;
    await loadEpisodeData(currentEpisodeNumber);
    showScene(currentSceneIndex);
});

// エピソード番号を指定してシーンとアセットを読み込むメイン関数
async function loadEpisodeData(episodeNumber) {
    showLoadingOverlay(true);
    console.log(`エピソード ${episodeNumber} のデータを読み込み中...`);
    currentEpisodeNumber = episodeNumber; // 現在のエピソード番号を更新
    localStorage.setItem('yh_current_episode', currentEpisodeNumber); // ローカルストレージに保存

    try {
        // 1. シーンデータを読み込む (ページネーション対応)
        const sceneFilter = `filters=episode[equals]${episodeNumber}`;
        currentEpisodeScenes = await fetchAllDataWithPagination(scenesApiBase, SCENES_API_KEY, sceneFilter);
        // シーン番号でソート
        currentEpisodeScenes.sort((a, b) => (a.sceneNumber || 0) - (b.sceneNumber || 0));
        
        console.log(`エピソード ${episodeNumber} のシーンデータ:`, currentEpisodeScenes);

        if (currentEpisodeScenes.length === 0) {
            alert(`エピソード ${episodeNumber} にシーンデータがありません。新しいシーンを追加してください。`);
            // シーンがない場合は処理を中断
            showLoadingOverlay(false); // ここで非表示にする
            return; 
        }
        
        // 2. 必要なアセットタグを収集
        const requiredBackgroundTags = new Set();
        const requiredCharacterTags = new Set(); // キャラクター名
        const requiredFaceTags = new Set(); // 表情タグ
        const requiredEffectTags = new Set();
        const requiredSpecialImageTags = new Set(); // special_image用

        currentEpisodeScenes.forEach(scene => {
            if (scene.background && scene.background !== "なし") {
                requiredBackgroundTags.add(scene.background);
            }
            // speakerとcharacter両方をキャラクター名として収集
            if (scene.speaker && scene.speaker !== "ナレーション") { 
                requiredCharacterTags.add(scene.speaker);
                if (scene.face) requiredFaceTags.add(scene.face);
            }
            if (scene.character && scene.character !== "なし") { 
                requiredCharacterTags.add(scene.character);
                if (scene.face) requiredFaceTags.add(scene.face); 
            }
            if (scene.special && scene.special !== "なし") {
                // specialがキャラクターの服装/姿切り替えの場合も考慮し、character_face_tagとして扱う可能性もある
                // 今回は「一枚絵」または「特殊エフェクト」のタグとして処理
                requiredEffectTags.add(scene.special); // 一旦エフェクトとして収集
                requiredSpecialImageTags.add(scene.special); // 一枚絵用のタグとしても収集
            }
        });

        // 3. 必要なアセットデータを読み込み、キャッシュに格納
        loadedAssets = { backgrounds: {}, characters: {}, effects: {}, specialImages: {} }; // キャッシュをリセット

        // 背景
        if (requiredBackgroundTags.size > 0) {
            const bgFilter = `asset_type[equals]background[and](${Array.from(requiredBackgroundTags).map(tag => `tag[equals]${tag}`).join('[or]')})`;
            const bgAssets = await fetchAllDataWithPagination(assetsApiBase, ASSETS_API_KEY, `filters=${bgFilter}`);
            bgAssets.forEach(asset => { if (asset.image) loadedAssets.backgrounds[asset.tag] = asset.image.url; });
        }

        // キャラクター
        if (requiredCharacterTags.size > 0) {
            let charFilter = `asset_type[equals]character[and](${Array.from(requiredCharacterTags).map(tag => `tag[equals]${tag}`).join('[or]')})`;
            if (requiredFaceTags.size > 0) { // 表情タグも指定されている場合
                charFilter += `[and](${Array.from(requiredFaceTags).map(tag => `character_face_tag[equals]${tag}`).join('[or]')})`;
            }
            const charAssets = await fetchAllDataWithPagination(assetsApiBase, ASSETS_API_KEY, `filters=${charFilter}`);
            charAssets.forEach(asset => {
                if (asset.character_face_image && asset.character_face_image.url) {
                    if (!loadedAssets.characters[asset.tag]) {
                        loadedAssets.characters[asset.tag] = {};
                    }
                    loadedAssets.characters[asset.tag][asset.character_face_tag || 'default'] = asset.character_face_image.url; 
                }
            });
        }

        // エフェクト (もし専用のアセットタイプがあるなら分けて取得)
        if (requiredEffectTags.size > 0) {
            const effectFilter = `asset_type[equals]effect[and](${Array.from(requiredEffectTags).map(tag => `tag[equals]${tag}`).join('[or]')})`;
            const effectAssets = await fetchAllDataWithPagination(assetsApiBase, ASSETS_API_KEY, `filters=${effectFilter}`);
            effectAssets.forEach(asset => { if (asset.image) loadedAssets.effects[asset.tag] = asset.image.url; });
        }

        // 特殊画像 (一枚絵など)
        if (requiredSpecialImageTags.size > 0) {
             const specialImageFilter = `asset_type[equals]special_image[and](${Array.from(requiredSpecialImageTags).map(tag => `tag[equals]${tag}`).join('[or]')})`;
             const specialImageAssets = await fetchAllDataWithPagination(assetsApiBase, ASSETS_API_KEY, `filters=${specialImageFilter}`);
             specialImageAssets.forEach(asset => { if (asset.image) loadedAssets.specialImages[asset.tag] = asset.image.url; });
        }


        console.log(`エピソード ${episodeNumber} で必要なアセットを読み込みました:`, loadedAssets);
        
        // UI更新
        currentSceneIndex = 0; // 新しいエピソードの開始シーンにリセット
        showScene(currentSceneIndex);
        populateSelectOptions(); // 選択肢を更新
        
    } catch (error) {
        console.error(`エピソード ${episodeNumber} のデータ読み込み中にエラーが発生しました:`, error);
        alert(`データの読み込みに失敗しました。APIキー、サービスID、エンドポイント、またはネットワーク接続を確認してください。\nエラー: ${error.message}`);
        currentEpisodeScenes = []; // エラー時はシーンデータをクリア
        loadedAssets = { backgrounds: {}, characters: {}, effects: {}, specialImages: {} }; // アセットもクリア
    } finally {
        showLoadingOverlay(false);
    }
}

// ページネーションに対応したデータ取得ヘルパー関数
async function fetchAllDataWithPagination(baseUrl, apiKey, filters = '') {
    let allContents = [];
    let offset = 0;
    const limit = 100;
    let totalCount = 0;

    do {
        const url = `${baseUrl}?limit=${limit}&offset=${offset}${filters ? '&' + filters : ''}`;
        const res = await fetch(url, { headers: { 'X-API-KEY': apiKey } });
        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(`API Error (${url}): ${res.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await res.json();
        allContents = allContents.concat(data.contents);
        totalCount = data.totalCount;
        offset += limit;
    } while (offset < totalCount);

    return allContents;
}


// --- シーン表示と編集 ---

// シーンを表示
function showScene(index) {
    if (currentEpisodeScenes.length === 0) {
        document.getElementById("scene-title").textContent = "シーンデータなし";
        document.getElementById("speaker").textContent = "";
        document.getElementById("text").textContent = "（この話にシーンがありません。シーンを追加してください。）";
        backgroundElement.style.backgroundImage = `url('assets/default_bg.jpg')`; // デフォルト背景
        characterElement.style.display = 'none'; // キャラクター非表示
        specialImageElement.style.display = 'none'; // 特殊画像非表示
        return;
    }

    if (index < 0 || index >= currentEpisodeScenes.length) {
        console.warn("無効なシーンインデックス:", index);
        currentSceneIndex = Math.max(0, Math.min(index, currentEpisodeScenes.length - 1)); // 有効な範囲に強制
        showScene(currentSceneIndex); // 再帰呼び出しで正しいシーンを表示
        return;
    }
    currentSceneIndex = index;
    const s = currentEpisodeScenes[currentSceneIndex];

    document.getElementById("current-episode-display").textContent = `第${s.episode || '不明'}話`;
    document.getElementById("scene-title").textContent = `#${s.sceneNumber || (currentSceneIndex + 1)}`;
    document.getElementById("speaker").textContent = s.speaker || "話者不明";
    document.getElementById("text").textContent = s.text || "（セリフなし）";
    
    // --- specialフィールドの処理 ---
    const specialImageTag = s.special; // specialの内容をタグとして使用

    if (specialImageTag && loadedAssets.specialImages[specialImageTag]) {
        // 一枚絵がある場合: 背景とキャラクターを非表示にし、一枚絵を表示
        backgroundElement.style.display = 'none';
        characterElement.style.display = 'none';
        specialImageElement.src = loadedAssets.specialImages[specialImageTag];
        specialImageElement.style.display = 'block';
        dialogueBox.style.height = '25%'; // 念のためダイアログボックスの高さは通常に
        dialogueBox.classList.remove('expanded'); // 一枚絵表示中は編集フォームを閉じとく
    } else {
        // 一枚絵がない場合: 通常の背景とキャラクターを表示
        backgroundElement.style.display = 'block';
        specialImageElement.style.display = 'none';
        specialImageElement.src = ""; // 画像をクリアしておく

        // 背景画像の設定
        const backgroundUrl = loadedAssets.backgrounds[s.background] || 'assets/default_bg.jpg'; 
        backgroundElement.style.backgroundImage = `url('${backgroundUrl}')`;
        
        // キャラクター画像の設定
        const charName = s.character || s.speaker; 
        const faceTag = s.face || 'normal'; 
        // specialがキャラクターの服装切り替えの場合、specialの内容をfaceTagとして利用
        const actualFaceTag = s.special && loadedAssets.characters[charName] && loadedAssets.characters[charName][s.special] ? s.special : faceTag;

        const characterImageUrl = (charName && loadedAssets.characters[charName] && loadedAssets.characters[charName][actualFaceTag]) 
                                  ? loadedAssets.characters[charName][actualFaceTag] 
                                  : 'assets/placeholder.png'; 
        
        characterElement.src = characterImageUrl;
        characterElement.style.display = (charName && charName !== "なし") ? 'block' : 'none'; 
        characterElement.classList.toggle("dimmed", s.speaker === "ナレーション");
    }

    // 編集フォームの値を更新
    document.getElementById("edit-speaker").value = s.speaker || "";
    document.getElementById("edit-text").value = s.text || "";
    document.getElementById("edit-face").value = s.face || "";
    document.getElementById("edit-bg").value = s.background || "";
    document.getElementById("edit-special").value = s.special || "";
    document.getElementById("edit-episode").value = s.episode || 1;
    document.getElementById("edit-scene-number").value = s.sceneNumber || (currentSceneIndex + 1);

    if (useVoice && s.speaker !== "ナレーション" && s.text) {
        speak(s.text);
    }
}

// シーンの編集内容をmicroCMSに適用
async function applyEdits() {
    if (currentEpisodeScenes.length === 0 && !document.getElementById("edit-episode").value) {
        alert("編集するシーンがありません。新しいシーンを追加してください。");
        return;
    }

    const s = currentEpisodeScenes[currentSceneIndex] || {}; // 新規追加の場合に備える
    const originalSpeaker = s.speaker; 

    // フォームから値を取得
    s.speaker = document.getElementById("edit-speaker").value;
    s.text = document.getElementById("edit-text").value;
    s.face = document.getElementById("edit-face").value;
    s.background = document.getElementById("edit-bg").value;
    s.special = document.getElementById("edit-special").value;
    s.episode = parseInt(document.getElementById("edit-episode").value) || 1;
    s.sceneNumber = parseInt(document.getElementById("edit-scene-number").value) || (currentSceneIndex + 1);

    try {
        const method = s.id ? 'PATCH' : 'POST'; 
        const url = s.id ? `${scenesApiBase}/${s.id}` : scenesApiBase;
        
        const dataToSend = {
            speaker: s.speaker,
            text: s.text,
            face: s.face,
            background: s.background,
            special: s.special,
            episode: s.episode,
            sceneNumber: s.sceneNumber,
            // chapterNumberは今回のロジックではシーン取得に利用しないため送信しないか、
            // 必要であれば編集フォームから取得して含める
            // chapterNumber: parseInt(document.getElementById("edit-chapter-number").value) || 1
        };

        const res = await fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'X-API-KEY': SCENES_API_KEY
            },
            body: JSON.stringify(dataToSend)
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(`API error! status: ${res.status}, message: ${JSON.stringify(errorData)}`);
        }

        if (method === 'POST') {
            const responseData = await res.json();
            s.id = responseData.id;
            // currentEpisodeScenes.push(s); // 新規作成時はリストに追加 (以下の再ロードで対応)
        }

        // シーンが現在のエピソードから移動した場合、またはエピソード番号が変更された場合
        if (s.episode !== currentEpisodeNumber) {
            alert(`シーンのエピソード番号が変更されました。\n現在のエピソードを再読み込みします。`);
            await loadEpisodeData(currentEpisodeNumber); // 現在のエピソードを再読み込み
        } else {
            // 現在のエピソード内での変更であれば、ソートと再表示
            // 新規追加や並び替えが発生するため、一度再ロードする方が確実
            await loadEpisodeData(currentEpisodeNumber); // エピソード内のデータを再読み込み
            // 変更されたシーンのインデックスを探し直す
            const updatedIndex = currentEpisodeScenes.findIndex(scene => scene.id === s.id);
            if (updatedIndex !== -1) currentSceneIndex = updatedIndex;
            showScene(currentSceneIndex);
            collapseLog();
            if (originalSpeaker !== s.speaker) {
                populateSelectOptions(); // 話者が変わったら選択肢を再構築
            }
        }
        alert("シーンが保存されました！");

    } catch (error) {
        console.error("シーンの保存中にエラーが発生しました:", error);
        alert(`シーンの保存に失敗しました。\nエラー: ${error.message}`);
    }
}

// シーンの削除機能
async function deleteScene() {
    if (currentEpisodeScenes.length === 0) {
        alert("削除するシーンがありません。");
        return;
    }
    if (!confirm("本当にこのシーンを削除しますか？")) {
        return;
    }

    const s = currentEpisodeScenes[currentSceneIndex];
    if (!s || !s.id) {
        alert("このシーンはまだ保存されていないか、IDがありません。");
        return;
    }

    try {
        await deleteSceneFromMicroCMS(s.id);
        alert("シーンが正常に削除されました。");
        // 削除後、現在のエピソードを再ロードする方が確実
        await loadEpisodeData(currentEpisodeNumber); 
        if (currentSceneIndex >= currentEpisodeScenes.length) { // 最後のシーンを削除した場合
            currentSceneIndex = Math.max(0, currentEpisodeScenes.length - 1);
        }
        showScene(currentSceneIndex);
        populateSelectOptions();
        collapseLog();
    } catch (error) {
        console.error("シーンの削除中にエラーが発生しました:", error);
        alert(`シーンの削除に失敗しました。\nエラー: ${error.message}`);
    }
}

async function deleteSceneFromMicroCMS(sceneId) {
    const res = await fetch(`${scenesApiBase}/${sceneId}`, {
        method: 'DELETE',
        headers: { 'X-API-KEY': SCENES_API_KEY }
    });
    if (!res.ok) {
        const errorData = await res.json();
        throw new Error(`API error during delete! status: ${res.status}, message: ${JSON.stringify(errorData)}`);
    }
}

// 新しいシーンの追加機能
async function addScene() {
    const newScene = {
        speaker: "新しい話者",
        text: "新しいセリフ",
        face: "",
        background: "default_bg",
        special: "",
        episode: currentEpisodeScenes[currentSceneIndex]?.episode || currentEpisodeNumber, // 現在のEPを継承
        sceneNumber: (currentEpisodeScenes[currentSceneIndex]?.sceneNumber || 0) + 1 // 現在のシーンの次
    };

    try {
        const res = await fetch(scenesApiBase, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-API-KEY': SCENES_API_KEY
            },
            body: JSON.stringify(newScene)
        });

        if (!res.ok) {
            const errorData = await res.json();
            throw new Error(`API error! status: ${res.status}, message: ${JSON.stringify(errorData)}`);
        }
        const createdScene = await res.json();
        newScene.id = createdScene.id; 

        // 新しいシーンが追加されたので、現在のエピソードデータを再ロード
        await loadEpisodeData(currentEpisodeNumber); 
        
        // 追加されたシーンのインデックスを探して移動
        const addedIndex = currentEpisodeScenes.findIndex(scene => scene.id === newScene.id);
        if (addedIndex !== -1) {
            currentSceneIndex = addedIndex;
        } else {
            currentSceneIndex = currentEpisodeScenes.length - 1; // 見つからなければ末尾
        }
        showScene(currentSceneIndex);
        populateSelectOptions();
        expandLog(); // 追加後、編集モードに
        alert("新しいシーンが追加されました！");
    } catch (error) {
        console.error("新しいシーンの追加中にエラーが発生しました:", error);
        alert(`新しいシーンの追加に失敗しました。\nエラー: ${error.message}`);
    }
}


// 選択肢（話者、表情、背景）を動的に生成
function populateSelectOptions() {
    // 既存の選択肢をクリア
    speakerSelect.innerHTML = '<option value="">--未選択--</option>';
    faceSelect.innerHTML = '<option value="">--未選択--</option>';
    bgSelect.innerHTML = '<option value="">--未選択--</option>';

    // 現在のエピソードシーンから話者を抽出
    const uniqueSpeakers = [...new Set(currentEpisodeScenes.map(s => s.speaker).filter(s => s && s !== "ナレーション"))].sort();
    uniqueSpeakers.forEach(speaker => {
        const option = document.createElement("option");
        option.value = speaker;
        option.textContent = speaker;
        speakerSelect.appendChild(option);
    });
    // ナレーションは必ず含める
    if (!uniqueSpeakers.includes("ナレーション")) {
        const narrationOption = document.createElement("option");
        narrationOption.value = "ナレーション";
        narrationOption.textContent = "ナレーション";
        speakerSelect.appendChild(narrationOption); // <-- ここを修正
    }

    // ロード済みのアセットから表情と背景を抽出
    const uniqueFaces = new Set();
    for (const charName in loadedAssets.characters) {
        for (const faceTag in loadedAssets.characters[charName]) {
            if (faceTag && faceTag !== 'default') uniqueFaces.add(faceTag); 
        }
    }
    Array.from(uniqueFaces).sort().forEach(face => {
        const option = document.createElement("option");
        option.value = face;
        option.textContent = face;
        faceSelect.appendChild(option);
    });

    const uniqueBgs = new Set(Object.keys(loadedAssets.backgrounds));
    Array.from(uniqueBgs).sort().forEach(bg => {
        const option = document.createElement("option");
        option.value = bg;
        option.textContent = bg;
        bgSelect.appendChild(option);
    });
    // デフォルト背景も必ず含める
    if (!uniqueBgs.has("default_bg")) {
        const defaultBgOption = document.createElement("option");
        defaultBgOption.value = "default_bg";
        defaultBgOption.textContent = "default_bg (デフォルト)";
        bgSelect.appendChild(defaultBgOption);
    }


    // 現在のシーンの値を選択肢に設定
    const s = currentEpisodeScenes[currentSceneIndex];
    if (s) {
        speakerSelect.value = s.speaker || "";
        faceSelect.value = s.face || "";
        bgSelect.value = s.background || "";
    }
}

// --- 進行状況の保存と読み込み ---
function saveProgress() {
    localStorage.setItem('yh_current_scene_index', currentSceneIndex);
    localStorage.setItem('yh_current_episode', currentEpisodeNumber);
    alert('進行状況を保存しました。');
}

async function loadProgress() {
    const svIndex = localStorage.getItem('yh_current_scene_index');
    const svEpisode = localStorage.getItem('yh_current_episode');

    if (svEpisode !== null && !isNaN(parseInt(svEpisode)) && parseInt(svEpisode) > 0) {
        const episodeToLoad = parseInt(svEpisode);
        if (episodeToLoad !== currentEpisodeNumber) {
            alert(`第${episodeToLoad}話から再開します。`);
            await loadEpisodeData(episodeToLoad); // 該当エピソードをロード
        }
        
        if (svIndex !== null && !isNaN(parseInt(svIndex))) {
            const indexToLoad = parseInt(svIndex);
            if (indexToLoad >= 0 && indexToLoad < currentEpisodeScenes.length) {
                currentSceneIndex = indexToLoad;
                showScene(currentSceneIndex);
                alert('保存地点から再開しました。');
            } else {
                alert('保存されたシーンインデックスが無効なため、話の最初から再開します。');
                currentSceneIndex = 0;
                showScene(currentSceneIndex);
            }
        } else {
            alert('保存されたシーンインデックスが見つからないため、話の最初から再開します。');
            currentSceneIndex = 0;
            showScene(currentSceneIndex);
        }
    } else {
        alert('有効な保存データがありません。');
    }
    closeModal();
}

// --- 音声読み上げ機能 ---
function toggleVoice() {
    useVoice = !useVoice;
    document.getElementById("voice-status").textContent = useVoice ? "オン" : "オフ";
    alert('読み上げ：' + (useVoice ? 'オン' : 'オフ'));
}

function speak(txt) {
    if ('speechSynthesis' in window) {
        const msg = new SpeechSynthesisUtterance(txt);
        msg.lang = 'ja-JP';
        speechSynthesis.cancel();
        speechSynthesis.speak(msg);
    } else {
        console.warn("お使いのブラウザは音声合成に対応していません。");
    }
}

// --- UI操作 ---
function expandLog() {
    document.getElementById('dialogue-box').classList.add('expanded');
}

function collapseLog() {
    document.getElementById('dialogue-box').classList.remove('expanded');
}

function openModal() {
    document.getElementById("modal").style.display = "flex";
}

function closeModal() {
    document.getElementById("modal").style.display = "none";
}

function showLoadingOverlay(show) {
    loadingOverlay.style.display = show ? 'flex' : 'none';
}

// --- エピソード移動 ---
async function changeEpisode(direction) {
    const nextEpisode = currentEpisodeNumber + direction;
    if (nextEpisode < 1) { // 最小エピソード番号は1とする
        alert("最初の話です。");
        return;
    }
    // ここで最大エピソード番号をチェックすることも可能ですが、
    // microCMSにデータがなければ自動的にシーンデータがない旨のメッセージが出ます。
    await loadEpisodeData(nextEpisode);
}

// --- JSONデータのダウンロードとアップロード ---

// 全シーンデータをダウンロード (ページネーション対応)
async function downloadAllScenes() {
    showLoadingOverlay(true);
    try {
        const allNovelScenes = await fetchAllDataWithPagination(scenesApiBase, SCENES_API_KEY);
        if (allNovelScenes.length === 0) {
            alert("ダウンロードするシーンがありません。");
            return;
        }
        const blob = new Blob([JSON.stringify(allNovelScenes, null, 2)], { type: "application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "all_scenes.json"; // ファイル名を変更
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        alert("全シーンデータを正常にダウンロードしました。");
    } catch (error) {
        console.error("全シーンデータのダウンロード中にエラーが発生しました:", error);
        alert(`全シーンデータのダウンロードに失敗しました。\nエラー: ${error.message}`);
    } finally {
        showLoadingOverlay(false);
    }
}

// scenes.jsonのアップロード
function uploadScenes() {
    document.getElementById('file-input').click();
}

async function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) {
        return;
    }
    showLoadingOverlay(true);
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const uploadedData = JSON.parse(e.target.result);
            if (!Array.isArray(uploadedData)) {
                throw new Error("アップロードされたJSONは配列である必要があります。");
            }

            // microCMSの現在の全シーンデータを取得し、IDをマップ
            const existingMicroCMSSchemas = await fetchAllDataWithPagination(scenesApiBase, SCENES_API_KEY);
            const existingIdMap = new Map(existingMicroCMSSchemas.map(s => [s.id, s]));

            // アップロードデータに含まれるIDと、存在しないIDを区別
            const uploadedIds = new Set(uploadedData.map(s => s.id).filter(Boolean));

            // microCMSに存在し、アップロードデータにないものを削除
            for (const existingScene of existingMicroCMSSchemas) {
                if (!uploadedIds.has(existingScene.id)) {
                    await deleteSceneFromMicroCMS(existingScene.id);
                    console.log(`シーン削除: ${existingScene.id}`);
                }
            }

            // アップロードされたデータをmicroCMSに反映 (更新または新規作成)
            for (const scene of uploadedData) {
                const method = existingIdMap.has(scene.id) ? 'PATCH' : 'POST';
                const url = method === 'PATCH' ? `${scenesApiBase}/${scene.id}` : scenesApiBase;
                
                // microCMSに送信するデータ (不要なフィールドは送らない)
                const dataToSend = {
                    speaker: scene.speaker,
                    text: scene.text,
                    face: scene.face,
                    background: scene.background,
                    special: scene.special,
                    episode: scene.episode || 1,
                    sceneNumber: scene.sceneNumber || 1
                };

                const res = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-KEY': SCENES_API_KEY
                    },
                    body: JSON.stringify(dataToSend)
                });
                if (!res.ok) {
                    const errorData = await res.json();
                    throw new Error(`API error during upload (${method} ${url})! status: ${res.status}, message: ${JSON.stringify(errorData)}`);
                }
                console.log(`シーン ${method === 'PATCH' ? '更新' : '追加'}: ID ${scene.id || '新規'}`);
            }
            
            alert("シーンデータが正常にアップロードされ、microCMSに同期されました！\n現在の話を再読み込みします。");
            closeModal();
            await loadEpisodeData(currentEpisodeNumber); // 同期後、現在の話のデータを再ロード
        } catch (error) {
            console.error("ファイルの読み込みまたはアップロード中にエラーが発生しました:", error);
            alert(`ファイルのアップロードに失敗しました。JSON形式が正しいか確認してください。\nエラー: ${error.message}`);
        } finally {
            showLoadingOverlay(false);
        }
    };
    reader.readAsText(file);
}


// --- イベントリスナー ---
const dialogueBox = document.getElementById('dialogue-box');
let startY = 0, startX = 0, touchStartTime = 0;

dialogueBox.addEventListener('touchstart', e => {
    startY = e.touches[0].clientY;
    startX = e.touches[0].clientX;
    touchStartTime = Date.now();
});

dialogueBox.addEventListener('touchend', e => {
    const endY = e.changedTouches[0].clientY;
    const endX = e.changedTouches[0].clientX;
    const dy = startY - endY;
    const dx = startX - endX;
    const dt = Date.now() - touchStartTime;

    const isExpanded = dialogueBox.classList.contains('expanded');

    // 上スワイプでログ展開
    if (dy > 50 && Math.abs(dx) < 50 && dt < 300 && !isExpanded) {
        expandLog();
        return;
    }
    // 下スワイプでログ格納
    if (endY - startY > 50 && Math.abs(dx) < 50 && dt < 300 && isExpanded) {
        collapseLog();
        return;
    }
    // 長押し（タップ＆ホールド）でログ展開/格納
    if (Math.abs(dy) < 10 && Math.abs(dx) < 10 && dt >= 500) {
        if (isExpanded) {
            collapseLog();
        } else {
            expandLog();
        }
        return;
    }
});

// bodyクリックでシーン遷移
document.body.addEventListener('click', e => {
    // モーダルが開いている場合、またはダイアログボックスが展開中の場合は何もしない
    if (document.getElementById("modal").style.display === "flex" || dialogueBox.classList.contains('expanded')) {
        return;
    }

    // 編集フォーム内の要素、ヘッダー内のコントロールがクリックされた場合は何もしない
    if (e.target.closest('#edit-form') || e.target.closest('#controls') || e.target.closest('#header')) {
        return;
    }

    const x = e.clientX;
    const w = window.innerWidth;
    
    if (x < w / 3) { // 画面左1/3をクリックで前へ
        currentSceneIndex--;
    } else if (x > w * 2 / 3) { // 画面右1/3をクリックで次へ
        currentSceneIndex++;
    } else { // 画面中央1/3をクリックでログ展開
        expandLog();
        return; // シーン遷移はしない
    }

    currentSceneIndex = Math.max(0, Math.min(currentSceneIndex, currentEpisodeScenes.length - 1));
    showScene(currentSceneIndex);
});
</script>
</body>
</html>
