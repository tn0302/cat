<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>勇者ハーレム - ノベルビューア（編集モード）</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; }
        #header { height: 48px; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: space-between; padding: 0 12px; }
        #novel-container { position: relative; height: calc(100% - 48px); touch-action: pan-y pinch-zoom; /* タッチ操作の許可 */ }
        #background, #special-image { position: absolute; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 0; }
        #special-image { object-fit: contain; background: none; } /* 一枚絵の場合 */
        #character { position: absolute; bottom: -30%; left: 50%; transform: translateX(-50%); max-height: 130%; object-fit: contain; z-index: 1; transition: filter 0.3s ease; }
        #character.dimmed { filter: brightness(0.5); }
        #dialogue-box {
            position: absolute; bottom: 0; width: 100%; min-height: 25%; max-height: 50%;
            background: rgba(0,0,0,0.8); padding: 20px; box-sizing: border-box; z-index: 10;
            display: flex; flex-direction: column; transition: all 0.3s ease;
            overflow: hidden; /* ログ展開時に隠れる部分 */
        }
        /* log-area削除に伴いexpanded時のdialogue-boxスタイル調整 */
        #dialogue-box.expanded {
            height: auto; /* 高さを自動調整 */
            max-height: 50%; /* 元の最大高さを維持 */
            justify-content: flex-end; /* 展開時は下から */
            padding-bottom: 20px; /* 下部操作ボタンとの重なり回避（不要になる可能性あり） */
        }
        #character-name { font-size: 1.2em; font-weight: bold; margin-bottom: 5px; color: #fff; }
        #dialogue-text { font-size: 1.1em; line-height: 1.5; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); user-select: text; /* テキスト選択可能に */ }
        #next-indicator { position: absolute; bottom: 10px; right: 20px; font-size: 2em; animation: bounce 1s infinite; }
        @keyframes bounce { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-10px); } 60% { transform: translateY(-5px); } }

        .control-button { background: #333; color: #fff; border: none; padding: 10px 15px; cursor: pointer; border-radius: 5px; font-size: 0.9em; }
        .control-button:hover { background: #555; }

        /* 編集フォームのモーダル */
        #modal { display: none; position: fixed; z-index: 200; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); justify-content: center; align-items: center; }
        #edit-form-container { background: #222; padding: 25px; border-radius: 8px; width: 90%; max-width: 500px; box-sizing: border-box; max-height: 90vh; overflow-y: auto; }
        #edit-form label { display: block; margin-bottom: 5px; font-weight: bold; color: #eee; }
        #edit-form input[type="text"], #edit-form textarea, #edit-form select {
            width: calc(100% - 20px); padding: 10px; margin-bottom: 15px;
            border: 1px solid #555; border-radius: 4px; background-color: #333; color: #fff;
            font-size: 1em;
        }
        #edit-form textarea { resize: vertical; min-height: 80px; }
        #edit-form button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; margin-right: 10px; }
        #edit-form button:hover { background: #0056b3; }
        #edit-form button.delete-button { background: #dc3545; }
        #edit-form button.delete-button:hover { background: #c82333; }
        #edit-form button.cancel-button { background: #6c757d; }
        #edit-form button.cancel-button:hover { background: #5a6268; }

        /* ヘッダーのドロップダウン */
        .dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #333;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 2;
            right: 0; /* 右揃え */
            border-radius: 4px;
            overflow: hidden;
        }
        .dropdown-content button {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            background: none;
            border: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-size: 0.9em;
        }
        .dropdown-content button:hover { background-color: #555; }
        .dropdown:hover .dropdown-content { display: block; }
        .dropbtn {
            background-color: #333;
            color: white;
            padding: 8px 12px;
            font-size: 16px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        .dropbtn:hover { background-color: #555; }

        /* エピソード選択ドロップダウン */
        #episode-select {
            padding: 5px 10px;
            border-radius: 4px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            font-size: 1em;
            margin-left: 10px;
            cursor: pointer;
        }
        #episode-select option {
            background-color: #333;
            color: white;
        }

        /* ローディングインジケータースタイル */
        #loading-indicator {
            display: none; /* 初期状態では非表示 */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 2em;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300; /* 他のモーダルより手前に */
        }
    </style>
</head>
<body>
    <div id="header">
        <div style="display: flex; align-items: center;">
            <button id="prev-episode-button" class="control-button" style="margin-right: 5px;">前へ</button>
            <select id="episode-select"></select>
            <button id="next-episode-button" class="control-button" style="margin-left: 5px;">次へ</button>
        </div>
        <div class="dropdown">
            <button class="dropbtn">メニュー</button>
            <div class="dropdown-content">
                <button id="add-scene-button">シーン追加</button>
                <button id="edit-scene-button">シーン編集</button>
                <button id="delete-scene-button">シーン削除</button>
                <button id="refresh-data-button">データ更新</button>
                <button id="upload-asset-button" onclick="window.location.href='asset_upload.html'">素材のアップロード</button>
                <button id="bulk-upload-button" onclick="window.location.href='bulk_upload.html'">シーン一括アップロード</button> 
            </div>
        </div>
    </div>
    <div id="novel-container">
        <div id="background"></div>
        <img id="special-image" src="" alt="" style="display: none;">
        <img id="character" src="" alt="" style="display: none;">
        <img id="effect-image" src="" alt="" style="display: none;">

        <div id="dialogue-box">
            <div id="character-name"></div>
            <div id="dialogue-text"></div>
            <div id="next-indicator">▼</div>
        </div>

    </div>

    <div id="modal">
        <div id="edit-form-container">
            <h2 id="modal-title">シーン編集</h2>
            <form id="edit-form">
                <label for="edit-episode">エピソード:</label>
                <input type="text" id="edit-episode" name="episode"><br>

                <label for="edit-scene-number">シーン番号:</label>
                <input type="text" id="edit-scene-number" name="sceneNumber"><br>

                <label for="edit-character">話者:</label>
                <input type="text" id="edit-character" name="character" list="characters-list">
                <datalist id="characters-list"></datalist><br>

                <label for="edit-text">本文:</label>
                <textarea id="edit-text" name="text"></textarea><br>

                <label for="edit-face">表情:</label>
                <input type="text" id="edit-face" name="face" list="faces-list">
                <datalist id="faces-list"></datalist><br>

                <label for="edit-special">特殊:</label>
                <input type="text" id="edit-special" name="special" list="special-list">
                <datalist id="special-list"></datalist><br>

                <label for="edit-background">背景:</label>
                <input type="text" id="edit-background" name="background" list="backgrounds-list">
                <datalist id="backgrounds-list"></datalist><br>

                <label for="edit-effect">エフェクト:</label>
                <input type="text" id="edit-effect" name="effect" list="effects-list">
                <datalist id="effects-list"></datalist><br>

                <button type="submit" id="save-scene-button">保存</button>
                <button type="button" id="cancel-edit-button" class="cancel-button">キャンセル</button>
                <button type="button" id="confirm-delete-button" class="delete-button" style="display: none;">削除確定</button>
            </form>
        </div>
    </div>

    <div id="loading-indicator">Now Loading...</div>

    <script>
        // Google Apps Script WebアプリのデプロイURLをここに設定
        const GAS_BASE_URL = 'https://cat-seven-blond.vercel.app/api/gas-proxy'; 
        // Vercelにデプロイしたapi/media.jsのURLを設定してください。
        // const MEDIA_UPLOAD_URL = 'https://cat-seven-blond.vercel.app/api/media'; // REMOVED

        // APIエンドポイント
        const SCENES_PROXY_PATH = `${GAS_BASE_URL}?api=scenes`;
        const ASSETS_PROXY_PATH = `${GAS_BASE_URL}?api=assets`;

        let currentEpisodeData = []; // 現在のエピソードの全シーンデータ
        let currentSceneIndex = 0; // 現在表示中のシーンのインデックス
        let loadedAssets = { backgrounds: {}, characters: {}, effects: {}, specialImages: {} }; // 読み込み済みアセット
        let allEpisodeNumbers = []; // 全エピソード番号
        let currentModalMode = ''; // 'add', 'edit', 'delete'

        // DOM要素の取得
        const dialogueText = document.getElementById('dialogue-text');
        const characterName = document.getElementById('character-name');
        const nextIndicator = document.getElementById('next-indicator');
        const characterImg = document.getElementById('character');
        const backgroundDiv = document.getElementById('background');
        const specialImage = document.getElementById('special-image');
        const effectImage = document.getElementById('effect-image');
        const dialogueBox = document.getElementById('dialogue-box');

        // モーダル関連の要素
        const modal = document.getElementById('modal');
        const editForm = document.getElementById('edit-form');
        const modalTitle = document.getElementById('modal-title');
        const saveSceneButton = document.getElementById('save-scene-button');
        const confirmDeleteButton = document.getElementById('confirm-delete-button');

       

        // ローディングインジケーター要素
        const loadingIndicator = document.getElementById('loading-indicator');


        // シーンをレンダリングする関数
        async function renderScene(scene) {
            // 背景画像の更新
            if (scene.background_image && scene.background_image !== "NOIMAGE") {
                backgroundEl.style.backgroundImage = `url('${scene.background_image}')`;
            } else {
                backgroundEl.style.backgroundImage = 'none'; // 画像がない場合は背景をクリア
            }

            // 特殊画像（effect_image）の更新
            if (scene.effect_image && scene.effect_image !== "NOIMAGE") {
                specialImageEl.src = scene.effect_image;
                specialImageEl.style.display = 'block';
                specialImageEl.style.opacity = 1;
            } else {
                specialImageEl.style.display = 'none';
                specialImageEl.style.opacity = 0;
            }
            
            // キャラクター画像の更新
            if (scene.character_image && scene.character_image !== "NOIMAGE") {
                characterEl.src = scene.character_image;
                characterEl.style.display = 'block';
                characterEl.style.opacity = 1;
            } else {
                characterEl.style.display = 'none';
                characterEl.style.opacity = 0;
            }


            // キャラクター名の更新 (speakerからcharacterへ変更)
            characterNameEl.textContent = scene.character || '';

            // テキストの更新
            sceneTextEl.textContent = scene.text || '';
            
           
        }


        // イベントリスナー
        document.getElementById('add-scene-button').addEventListener('click', () => openEditModal('add'));
        document.getElementById('edit-scene-button').addEventListener('click', () => openEditModal('edit'));
        document.getElementById('delete-scene-button').addEventListener('click', () => openEditModal('delete'));
        document.getElementById('cancel-edit-button').addEventListener('click', () => closeModal());
        confirmDeleteButton.addEventListener('click', () => deleteScene());
        editForm.addEventListener('submit', (e) => {
            e.preventDefault();
            applyEdits();
        });

        // document.getElementById('upload-asset-button').addEventListener('click', () => openAssetUploadModal()); // REMOVED
        // document.getElementById('cancel-upload-button').addEventListener('click', () => closeAssetUploadModal()); // REMOVED
        // assetImageFileInput.addEventListener('change', handleImageUploadInModal); // REMOVED
        // registerAssetInModalButton.addEventListener('click', registerAssetInGASFromModal); // REMOVED

        document.getElementById('refresh-data-button').addEventListener('click', () => {
            if (confirm('全てのデータを再読み込みしますか？現在のエピソードの変更は破棄されます。')) {
                const currentEpisode = document.getElementById('episode-select').value;
                initialize(parseInt(currentEpisode)); // 現在のエピソードを再読み込み
            }
        });

        document.getElementById('episode-select').addEventListener('change', (e) => {
            const selectedEpisode = parseInt(e.target.value);
            loadEpisodeData(selectedEpisode);
        });
        document.getElementById('prev-episode-button').addEventListener('click', () => changeEpisode(-1));
        document.getElementById('next-episode-button').addEventListener('click', () => changeEpisode(1));


        // タッチイベント用変数
        let touchStartTime;
        let startX;
        let startY;
        let endX;
        let endY;

        // スワイプ/タップ検出
        const novelContainer = document.getElementById('novel-container');
        novelContainer.addEventListener('touchstart', e => {
            touchStartTime = Date.now();
            startX = e.touches?.[0]?.clientX;
            startY = e.touches?.[0]?.clientY;
        });

        novelContainer.addEventListener('touchend', e => {
            // モーダルが表示されている場合やヘッダーを操作した場合は何もしない
            if (document.getElementById("modal").style.display === "flex" ||
                // document.getElementById("asset-upload-modal").style.display === "flex" || // REMOVED
                e.target.closest('#edit-form') || e.target.closest('#header') /* || e.target.closest('#asset-upload-form') */) { // REMOVED asset-upload-form check
                return;
            }

            if (!startX || !startY) return; // startX/Yが取得できていない場合は何もしない

            endX = e.changedTouches?.[0]?.clientX;
            endY = e.changedTouches?.[0]?.clientY;

            const deltaX = endX - startX;
            const deltaY = endY - startY;
            const deltaTime = Date.now() - touchStartTime;

            // スワイプ判定 (水平方向の移動が垂直方向より大きく、かつ一定時間内)
            const SWIPE_THRESHOLD = 50; // スワイプと認識する水平移動の閾値 (px)
            const TAP_TIME_THRESHOLD = 300; // タップと認識する時間 (ms)
            const TAP_MOVE_THRESHOLD = 20; // タップと認識する移動の許容範囲 (px)

            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > SWIPE_THRESHOLD && deltaTime < TAP_TIME_THRESHOLD) {
                if (deltaX > 0) { // 右スワイプ
                    prevScene(); 
                } else { // 左スワイプ
                    nextScene();
                }
            } else if (Math.abs(deltaX) < TAP_MOVE_THRESHOLD && Math.abs(deltaY) < TAP_MOVE_THRESHOLD && deltaTime < TAP_TIME_THRESHOLD) {
                // タップ判定 (短い移動で、かつ一定時間内)
                // タップ位置によってシーンを切り替え
                const containerWidth = novelContainer.offsetWidth;
                const tapXPercentage = endX / containerWidth; // 画面幅に対するタップ位置の割合

                if (tapXPercentage < 0.5) { // 左半分をタップ
                    prevScene();
                } else { // 右半分をタップ (またはそれ以外)
                    nextScene();
                }
            }

            // タッチ開始座標をリセット
            startX = null;
            startY = null;
        });

        // dialogueBoxのタッチイベントは、novelContainerで一括処理するため、基本的にはここでは何もしない。
        dialogueBox.addEventListener('touchstart', e => { /* do nothing */ });
        dialogueBox.addEventListener('touchend', e => { /* do nothing */ });

        // === fetchJson ヘルパー関数を定義 ===
        async function fetchJson(url, options = {}) {
            const response = await fetch(url, options);

            if (!response.ok) {
                let errorData;
                try {
                    errorData = await response.json();
                } catch (e) {
                    // JSONとしてパースできない場合
                    errorData = { message: response.statusText || 'Unknown error', status: response.status };
                }
                const error = new Error(errorData.message || `HTTP error! status: ${response.status}`);
                error.response = response;
                error.data = errorData;
                throw error;
            }

            return response.json();
        }

        async function fetchAllDataWithPagination(proxyPath, episode = null, filters = '') {
            let url = proxyPath;
            const params = new URLSearchParams();

            // scenes_proxy_pathの場合のみepisodeを追加
            if (proxyPath === SCENES_PROXY_PATH && episode !== null) {
                params.append('episode', episode);
            }
            
            // filtersがあれば追加
            if (filters) {
                // filtersはエンコードされていることを想定し、そのまま追加
                params.append('filters', filters);
            }
            
            // パラメータがあればURLに結合
            if (params.toString()) {
                // proxyPathが既に ? を含んでいれば & で結合、そうでなければ ? で結合
                url += (proxyPath.includes('?') ? '&' : '?') + params.toString();
            }

            // fetchJson を使用
            let data = await fetchJson(url);

            // ASSETS_PROXY_PATH からの応答には 'contents' ラッパーがあることを考慮する
            if (proxyPath === ASSETS_PROXY_PATH && data && typeof data === 'object' && 'contents' in data) {
                data = data.contents;
            }
            
            // 戻り値が配列でない場合のエラーハンドリング
            if (!Array.isArray(data)) {
                throw new Error(`API returned invalid data format. Expected an array but got: ${JSON.stringify(data)}`);
            }

            return data;
        }

        async function loadEpisodeData(episodeNumber) {
            loadingIndicator.style.display = 'flex'; // ローディング表示
            try {
                // シーンデータを取得
                currentEpisodeData = await fetchAllDataWithPagination(SCENES_PROXY_PATH, episodeNumber);
                // sceneNumber でソート
                currentEpisodeData.sort((a, b) => a.sceneNumber - b.sceneNumber);

                // 必要なアセットタグを収集
                const requiredBackgroundTags = new Set();
                const requiredCharacterTags = new Set();
                const requiredSpecialTags = new Set();
                const requiredEffectTags = new Set();

                currentEpisodeData.forEach(s => {
                    if (s.background && !s.background_image) requiredBackgroundTags.add(s.background);
                    if (s.character && !s.character_image) requiredCharacterTags.add(s.character);
                    // 表情はキャラクターアセットの一部として扱うため、個別のタグ収集は不要
                    if (s.special && !s.special_image) requiredSpecialTags.add(s.special);
                    if (s.effect && !s.effect_image) requiredEffectTags.add(s.effect);
                });

                // 必要なアセットデータを読み込み、キャッシュに格納
                loadedAssets = { backgrounds: {}, characters: {}, effects: {}, specialImages: {} };

                // 背景
                if (requiredBackgroundTags.size > 0) {
                    const bgFilters = Array.from(requiredBackgroundTags).map(tag => `tag[equals]${encodeURIComponent(tag)}`).join('[or]');
                    const bgAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, null, `asset_type[equals]background[and](${bgFilters})`);
                    bgAssets.forEach(asset => { 
                        if (asset.tag && asset.image) {
                            loadedAssets.backgrounds[asset.tag] = asset.image;
                        }
                    });
                }
                
                // キャラクター (話者と表情)
                if (requiredCharacterTags.size > 0) {
                    const charFilters = Array.from(requiredCharacterTags).map(tag => `tag[equals]${encodeURIComponent(tag)}`).join('[or]');
                    const charAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, null, `asset_type[equals]character[and](${charFilters})`);
                    charAssets.forEach(asset => { 
                        if (asset.tag && asset.image) {
                            loadedAssets.characters[asset.tag] = {
                                image: asset.image,
                                face_tags: asset.character_face_tag ? String(asset.character_face_tag).split(',').map(t => t.trim()) : []
                            };
                        }
                    });
                }

                // 特殊画像
                if (requiredSpecialTags.size > 0) {
                    const specialFilters = Array.from(requiredSpecialTags).map(tag => `tag[equals]${encodeURIComponent(tag)}`).join('[or]');
                    const specialAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, null, `asset_type[equals]special_image[and](${specialFilters})`);
                    specialAssets.forEach(asset => {
                        if (asset.tag && asset.image) {
                            loadedAssets.specialImages[asset.tag] = asset.image;
                        }
                    });
                }

                // エフェクト
                if (requiredEffectTags.size > 0) {
                    const effectFilters = Array.from(requiredEffectTags).map(tag => `tag[equals]${encodeURIComponent(tag)}`).join('[or]');
                    const effectAssets = await fetchAllDataWithPagination(ASSETS_PROXY_PATH, null, `asset_type[equals]effect[and](${effectFilters})`);
                    effectAssets.forEach(asset => {
                        if (asset.tag && asset.image) {
                            loadedAssets.effects[asset.tag] = asset.image;
                        }
                    });
                }

                populateSelectOptions();
                currentSceneIndex = 0;
                showScene(currentEpisodeData[currentSceneIndex]);
                updateNavigationButtons();
                updateEpisodeSelect();

            } catch (error) {
                console.error("エピソードデータ読み込み中にエラーが発生しました:", error);
                dialogueText.textContent = `ep ${episodeNumber} のデータ読み込み中にエラーが発生しました: ${error.message}`;
                characterName.textContent = "エラー";
                nextIndicator.style.display = 'none';
            } finally {
                loadingIndicator.style.display = 'none'; // ロード完了（成功/失敗問わず）で非表示
            }
        }

        function showScene(s) {
            if (!s) {
                console.warn("表示するシーンデータがありません。");
                characterName.textContent = "終了";
                dialogueText.textContent = "これ以上シーンはありません。";
                nextIndicator.style.display = 'none';
                characterImg.style.display = 'none';
                backgroundDiv.style.backgroundImage = 'none';
                specialImage.style.display = 'none';
                effectImage.style.display = 'none';
                return;
            }

            characterName.textContent = s.character || '';
            dialogueText.textContent = s.text || '';
            nextIndicator.style.display = 'block';

            // character_image が優先、なければタグからロード
            if (s.character_image) {
                characterImg.src = s.character_image;
                characterImg.style.display = 'block';
            } else if (s.character && loadedAssets.characters[s.character] && loadedAssets.characters[s.character].image) {
                characterImg.src = loadedAssets.characters[s.character].image;
                characterImg.style.display = 'block';
            } else {
                characterImg.src = '';
                characterImg.style.display = 'none';
            }

            // background_image が優先、なければタグからロード
            if (s.background_image) {
                backgroundDiv.style.backgroundImage = `url(${s.background_image})`;
            } else if (s.background && loadedAssets.backgrounds[s.background]) {
                backgroundDiv.style.backgroundImage = `url(${loadedAssets.backgrounds[s.background]})`;
            } else {
                backgroundDiv.style.backgroundImage = '';
            }
            
            // special_image が優先、なければタグからロード
            if (s.special_image) {
                specialImage.src = s.special_image;
                specialImage.style.display = 'block';
            } else if (s.special && loadedAssets.specialImages[s.special]) {
                specialImage.src = loadedAssets.specialImages[s.special];
                specialImage.style.display = 'block';
            } else {
                specialImage.src = '';
                specialImage.style.display = 'none';
            }

            // effect_image が優先、なければタグからロード
            if (s.effect_image) {
                effectImage.src = s.effect_image;
                effectImage.style.display = 'block';
            } else if (s.effect && loadedAssets.effects[s.effect]) {
                effectImage.src = loadedAssets.effects[s.effect];
                effectImage.style.display = 'block';
            } else {
                effectImage.src = '';
                effectImage.style.display = 'none';
            }

            // 表情クラスの適用（キャラクターが存在し、表情タグが定義されている場合のみ）
            characterImg.className = 'character'; // 既存のクラスをリセット
            if (s.face && s.character && loadedAssets.characters[s.character] && loadedAssets.characters[s.character].face_tags.includes(String(s.face))) {
                // ここでは、特定の表情に応じたCSSクラスをキャラクター画像に適用するロジックを想定
                // 例: characterImg.classList.add(`face-${s.face}`);
                // 現状は特別なCSSが定義されていないため、この行は影響しないが、将来的な拡張性のため残す
            }
        }

        function nextScene() {
            if (currentSceneIndex < currentEpisodeData.length - 1) {
                currentSceneIndex++;
                showScene(currentEpisodeData[currentSceneIndex]);
                updateNavigationButtons();
            } else {
                const currentEpisode = parseInt(document.getElementById('episode-select').value);
                const currentEpisodeIndex = allEpisodeNumbers.indexOf(currentEpisode);
                if (currentEpisodeIndex < allEpisodeNumbers.length - 1) {
                    const nextEpisode = allEpisodeNumbers[currentEpisodeIndex + 1];
                    document.getElementById('episode-select').value = nextEpisode;
                    loadEpisodeData(nextEpisode);
                } else {
                    alert('これ以上シーンはありません。');
                }
            }
        }

        function prevScene() {
            if (currentSceneIndex > 0) {
                currentSceneIndex--;
                showScene(currentEpisodeData[currentSceneIndex]);
                updateNavigationButtons();
            } else {
                const currentEpisode = parseInt(document.getElementById('episode-select').value);
                const currentEpisodeIndex = allEpisodeNumbers.indexOf(currentEpisode);
                if (currentEpisodeIndex > 0) {
                    const prevEpisode = allEpisodeNumbers[currentEpisodeIndex - 1];
                    document.getElementById('episode-select').value = prevEpisode;
                    loadEpisodeData(prevEpisode);
                } else {
                    alert('これ以上シーンはありません。');
                }
            }
        }

        // 編集フォームの選択肢を更新
        function populateSelectOptions() {
            const charactersDatalist = document.getElementById('characters-list');
            const facesDatalist = document.getElementById('faces-list');
            const backgroundsDatalist = document.getElementById('backgrounds-list');
            const specialDatalist = document.getElementById('special-list');
            const effectsDatalist = document.getElementById('effects-list');

            charactersDatalist.innerHTML = '';
            facesDatalist.innerHTML = '';
            backgroundsDatalist.innerHTML = '';
            specialDatalist.innerHTML = '';
            effectsDatalist.innerHTML = '';

            Object.keys(loadedAssets.characters).forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                charactersDatalist.appendChild(option);
            });

            const uniqueFaces = new Set();
            Object.values(loadedAssets.characters).forEach(char => {
                char.face_tags.forEach(face => uniqueFaces.add(face));
            });
            Array.from(uniqueFaces).sort().forEach(face => {
                const option = document.createElement('option');
                option.value = face;
                facesDatalist.appendChild(option);
            });

            Object.keys(loadedAssets.backgrounds).forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                backgroundsDatalist.appendChild(option);
            });

            Object.keys(loadedAssets.specialImages).forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                specialDatalist.appendChild(option);
            });

            Object.keys(loadedAssets.effects).forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                effectsDatalist.appendChild(option);
            });
        }

        function openEditModal(mode) {
            modal.style.display = 'flex';
            currentModalMode = mode; // モーダルモードを保存
            confirmDeleteButton.style.display = 'none';
            saveSceneButton.style.display = 'inline-block'; // デフォルトで表示

            editForm.reset(); // フォームをリセット
            
            // 全ての入力フィールドを編集可能に設定（deleteモードでreadonlyになるためリセット）
            editForm.querySelectorAll('input, textarea').forEach(input => input.readOnly = false);


            if (mode === 'add') {
                modalTitle.textContent = 'シーン追加';
                saveSceneButton.textContent = '追加';
                document.getElementById('edit-episode').value = document.getElementById('episode-select').value;
                // 現在のシーンの次の番号を初期値として設定
                if (currentEpisodeData.length > 0) {
                    document.getElementById('edit-scene-number').value = currentEpisodeData[currentSceneIndex].sceneNumber + 1;
                } else {
                    document.getElementById('edit-scene-number').value = 1; // エピソードが空の場合
                }
            } else if (mode === 'edit') {
                modalTitle.textContent = 'シーン編集';
                saveSceneButton.textContent = '保存';
                const currentScene = currentEpisodeData[currentSceneIndex];
                if (currentScene) {
                    // IDは表示しないが、内部的には現在のシーンのIDを使用
                    // document.getElementById('edit-id').value = currentScene.id; // この行は不要
                    for (const key in currentScene) {
                        const input = document.getElementById(`edit-${key}`);
                        if (input) input.value = currentScene[key];
                    }
                } else {
                    alert('編集するシーンがありません。');
                    closeModal();
                    return;
                }
            } else if (mode === 'delete') {
                modalTitle.textContent = 'シーン削除';
                saveSceneButton.style.display = 'none'; // 保存ボタンを非表示
                confirmDeleteButton.style.display = 'inline-block'; // 削除確定ボタンを表示
                const currentScene = currentEpisodeData[currentSceneIndex];
                if (currentScene) {
                    // IDは表示しないが、内部的には現在のシーンのIDを使用
                    // document.getElementById('edit-id').value = currentScene.id; // この行は不要
                    for (const key in currentScene) {
                        const input = document.getElementById(`edit-${key}`);
                        if (input) {
                            input.value = currentScene[key];
                            input.readOnly = true; // 削除モードでは編集不可にする
                        }
                    }
                } else {
                    alert('削除するシーンがありません。');
                    closeModal();
                    return;
                }
            }
        }

        function closeModal() {
            modal.style.display = 'none';
            currentModalMode = ''; // モードをリセット
        }

        async function applyEdits() {
            const formSceneData = {};
            const formData = new FormData(editForm);
            for (const [key, value] of formData.entries()) {
                formSceneData[key] = value;
            }

            // currentModalMode を使用して 'add' か 'edit' を判断
            const method = (currentModalMode === 'add') ? 'POST' : 'PUT';
            let url = SCENES_PROXY_PATH;

            if (method === 'PUT') {
                const currentScene = currentEpisodeData[currentSceneIndex];
                if (!currentScene || !currentScene.id) {
                    alert('編集対象のシーンIDが見つかりません。');
                    return;
                }
                url += `&id=${currentScene.id}`; // 既存シーンの更新時はIDをURLに含める
            }
            // POST (追加) の場合はIDをURLに含めない。GAS側で自動生成される。

            try {
                const res = await fetchJson(url, { // fetchJson を使用
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                        // PUT/DELETEメソッドオーバーライドをPOSTリクエストとして送信する場合
                        ...(method !== 'POST' && { 'X-HTTP-Method-Override': method }) 
                    },
                    body: JSON.stringify(formSceneData),
                });

                alert(`シーンを${(currentModalMode === 'add') ? '追加' : '更新'}しました！`);
                closeModal();
                // データ更新後に現在のエピソードを再読み込みし、最新状態を反映
                loadEpisodeData(parseInt(document.getElementById('episode-select').value));
            } catch (error) {
                console.error("シーン操作中にエラーが発生しました:", error);
                alert(`シーン操作に失敗しました: ${error.message}`);
            }
        }

        async function deleteScene() {
            const currentScene = currentEpisodeData[currentSceneIndex];
            if (!currentScene || !currentScene.id) {
                alert('削除するシーンIDが見つかりません。');
                return;
            }
            const sceneIdToDelete = currentScene.id;

            if (!confirm(`ID: ${sceneIdToDelete} のシーンを本当に削除しますか？`)) {
                return;
            }

            try {
                const res = await fetchJson(`${SCENES_PROXY_PATH}&id=${sceneIdToDelete}`, { // fetchJson を使用
                    method: 'DELETE', // Webアプリ側で_method=DELETEとして処理される
                });

                alert(`シーンID: ${sceneIdToDelete} を削除しました！`);
                closeModal();
                // シーン削除後、現在表示中のエピソードを再読み込みし、シーンが削除された状態を反映
                // currentSceneIndexが削除により範囲外になる可能性があるので、リセットする
                currentSceneIndex = Math.max(0, currentSceneIndex - 1); // 1つ前のシーンへ
                loadEpisodeData(parseInt(document.getElementById('episode-select').value));
            } catch (error) {
                console.error("シーン削除中にエラーが発生しました:", error);
                alert(`シーン削除に失敗しました: ${error.message}`);
            }
        }

        // openAssetUploadModal function REMOVED
        // closeAssetUploadModal function REMOVED
        // handleImageUploadInModal function REMOVED
        // uploadFileToCloudinary function REMOVED
        // registerAssetInGASFromModal function REMOVED

        async function populateEpisodeSelect() {
            loadingIndicator.style.display = 'flex'; // ローディング表示
            try {
                const allScenes = await fetchAllDataWithPagination(SCENES_PROXY_PATH);
                const episodeNumbers = new Set();
                allScenes.forEach(s => {
                    // episodeが数値で、かつ有効な数値であることを確認
                    if (s.episode && !isNaN(Number(s.episode))) {
                        episodeNumbers.add(parseInt(s.episode));
                    }
                });
                allEpisodeNumbers = Array.from(episodeNumbers).sort((a, b) => a - b);

                const episodeSelect = document.getElementById('episode-select');
                episodeSelect.innerHTML = ''; // 既存のオプションをクリア

                if (allEpisodeNumbers.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'エピソードなし';
                    episodeSelect.appendChild(option);
                    return;
                }

                allEpisodeNumbers.forEach(epNum => {
                    const option = document.createElement('option');
                    option.value = epNum;
                    option.textContent = `エピソード ${epNum}`;
                    episodeSelect.appendChild(option);
                });

                // URLパラメータから初期エピソードを取得、なければ最初のエピソードを選択
                const urlParams = new URLSearchParams(window.location.search);
                const initialEpisodeParam = parseInt(urlParams.get('episode'));
                const initialEpisode = (!isNaN(initialEpisodeParam) && allEpisodeNumbers.includes(initialEpisodeParam)) 
                                        ? initialEpisodeParam 
                                        : allEpisodeNumbers[0];
                
                episodeSelect.value = initialEpisode;
                loadEpisodeData(initialEpisode); // 選択されたエピソードのデータをロード

            } catch (error) {
                console.error("エピソード番号の取得中にエラーが発生しました:", error);
                alert(`エピソード番号の取得に失敗しました: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none'; // ロード完了（成功/失敗問わず）で非表示
            }
        }

        function updateEpisodeSelect() {
            const currentEpisode = parseInt(document.getElementById('episode-select').value);
            const episodeSelect = document.getElementById('episode-select');
            
            if (currentEpisode && allEpisodeNumbers.includes(currentEpisode)) {
                episodeSelect.value = currentEpisode;
            }
            updateNavigationButtons();
        }

        function updateNavigationButtons() {
            const currentEpisode = parseInt(document.getElementById('episode-select').value);
            const currentEpisodeIndex = allEpisodeNumbers.indexOf(currentEpisode);

            document.getElementById('prev-episode-button').disabled = (currentEpisodeIndex <= 0);
            document.getElementById('next-episode-button').disabled = (currentEpisodeIndex >= allEpisodeNumbers.length - 1);
        }

        function changeEpisode(direction) {
            const currentEpisode = parseInt(document.getElementById('episode-select').value);
            const currentEpisodeIndex = allEpisodeNumbers.indexOf(currentEpisode);
            const newEpisodeIndex = currentEpisodeIndex + direction;

            if (newEpisodeIndex >= 0 && newEpisodeIndex < allEpisodeNumbers.length) {
                const newEpisode = allEpisodeNumbers[newEpisodeIndex];
                document.getElementById('episode-select').value = newEpisode;
                loadEpisodeData(newEpisode);
            }
        }

        async function initialize() {
            // ここに `GAS_BASE_URL` のチェックを追加しました。
            // 正しいWebアプリのURLに置き換えてください。
            // 例: const GAS_BASE_URL = 'https://script.google.com/macros/s/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/exec';
            if (GAS_BASE_URL === 'https://cat-seven-blond.vercel.app/api/gas-proxy' || !GAS_BASE_URL.startsWith('https://cat-seven-blond.vercel.app/api/gas-proxy')) {
                //alert('GAS_BASE_URLが正しく設定されていません。`index.html`ファイル内の`GAS_BASE_URL`を、デプロイしたVercelプロキシのURLに置き換えてください。');
                //return;
            }
            await populateEpisodeSelect();
        }

        window.addEventListener('load', () => initialize());
    </script>
</body>
</html>